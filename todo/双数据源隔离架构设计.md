# DB-Doctor 双数据源隔离架构设计

## 一、设计原则

**"上帝的归上帝，凯撒的归凯撒"**

### 核心理念

- **用户的 MySQL（生产环境）**：只读访问，零侵入、零污染
- **DB-Doctor 的 H2（本地数据）**：存储分析历史、SQL 指纹等元数据

### 设计目标

1. ✅ **零侵入**：不在用户 MySQL 中创建任何表
2. ✅ **绿色中间件**：删除中间件目录即可完全卸载
3. ✅ **智能去重**：相同类型的 SQL 只分析一次
4. ✅ **历史记录**：保存所有 AI 分析报告

---

## 二、架构设计

### 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    DB-Doctor 中间件                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │              H2 数据库（主数据源）                  │    │
│  │         ↓ 存储位置：./data/db-doctor-internal.mv.db  │    │
│  │                                                      │    │
│  │  • SlowQueryHistory（分析历史）                     │    │
│  │  • SQL 指纹（去重）                                 │    │
│  │  • AI 分析报告（Markdown）                          │    │
│  │  • 统计数据（出现次数、首次/最近时间）              │    │
│  └────────────────────────────────────────────────────┘    │
│                          ↓                                  │
│                 JPA Repository                             │
│                          ↓                                  │
│  ┌────────────────────────────────────────────────────┐    │
│  │                  AnalysisService                   │    │
│  │  • SQL 指纹计算（Druid）                           │    │
│  │  • 去重判断（查询 H2）                             │    │
│  │  • AI 分析调度                                     │    │
│  │  • 历史记录保存（H2）                              │    │
│  └────────────────────────────────────────────────────┘    │
│                          ↓                                  │
│  ┌────────────────────────────────────────────────────┐    │
│  │            用户 MySQL（目标数据源）                  │    │
│  │         ↓ 只读访问：information_schema               │    │
│  │                                                      │    │
│  │  • mysql.slow_log（慢查询日志）                     │    │
│  │  • 表结构信息（information_schema.TABLES）          │    │
│  │  • 索引信息（information_schema.STATISTICS）        │    │
│  │  • 执行计划（EXPLAIN）                              │    │
│  └────────────────────────────────────────────────────┘    │
│                          ↑                                  │
│                 JdbcTemplate                              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 数据流向

```
用户 MySQL (只读)
    ↓
targetJdbcTemplate
    ↓
SlowLogTableMonitor (定时轮询)
    ↓
提取 SlowQueryLog
    ↓
AnalysisService (去重判断)
    ↓
计算 SQL 指纹 (Druid)
    ↓
查询 H2 数据库
    ↓
├─ 新 SQL → 触发 AI 分析 → 保存报告到 H2 → 发送通知
└─ 老 SQL → 更新计数 → 跳过分析
```

---

## 三、数据源配置

### 3.1 H2 数据源（主数据源）

**用途**：存储 DB-Doctor 自身的数据

**配置**（application.yml）：
```yaml
spring:
  datasource:
    # H2 存文件到当前目录下的 data 文件夹
    url: jdbc:h2:file:./data/db-doctor-internal;DB_CLOSE_DELAY=-1;MODE=MySQL
    driver-class-name: org.h2.Driver
    username: sa
    password:

  jpa:
    hibernate:
      ddl-auto: update  # 自动建表
    show-sql: false
    database-platform: org.hibernate.dialect.H2Dialect
```

**配置参数说明**：
- `file:./data/db-doctor-internal`：数据存储在当前目录的 `data` 文件夹下
- `DB_CLOSE_DELAY=-1`：最后一个连接关闭后不关闭数据库（提高性能）
- `MODE=MySQL`：使用 MySQL 兼容模式

**特点**：
- ✅ Spring Boot 默认数据源
- ✅ JPA / Hibernate 自动识别
- ✅ 自动建表（ddl-auto: update）
- ✅ 数据存储为本地文件

### 3.2 MySQL 目标数据源

**用途**：只读访问用户的 MySQL

**配置**（application.yml）：
```yaml
target-db:
  url: jdbc:mysql://localhost:3306/information_schema?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai
  username: db_doctor
  password: your_password
  driver-class-name: com.mysql.cj.jdbc.Driver
```

**配置类**（TargetDataSourceConfig.java）：
```java
@Configuration
public class TargetDataSourceConfig {

    @Bean
    @ConfigurationProperties(prefix = "target-db")
    public DataSourceProperties targetDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean("targetDataSource")
    public DataSource targetDataSource() {
        return targetDataSourceProperties()
            .initializeDataSourceBuilder()
            .build();
    }

    @Bean("targetJdbcTemplate")
    public JdbcTemplate targetJdbcTemplate(
        @Qualifier("targetDataSource") DataSource dataSource
    ) {
        return new JdbcTemplate(dataSource);
    }
}
```

**使用示例**：
```java
@Service
public class SlowLogTableMonitor {

    @Autowired
    @Qualifier("targetJdbcTemplate")  // ⚠️ 连用户 MySQL
    private JdbcTemplate targetJdbcTemplate;

    @Scheduled(fixedDelay = 60000)
    public void pollSlowLog() {
        // 查询用户的 MySQL
        String sql = """
            SELECT
                start_time,
                user_host,
                TIME_TO_SEC(query_time) as query_time_sec,
                db,
                CONVERT(sql_text USING utf8) AS sql_content
            FROM mysql.slow_log
            WHERE start_time > ?
            ORDER BY start_time ASC
            LIMIT 100
            """;

        List<Map<String, Object>> logs = targetJdbcTemplate.queryForList(sql, lastCheckTime);
        // ...
    }
}
```

---

## 四、数据模型设计

### 4.1 SlowQueryHistory 实体（H2）

```java
@Entity
@Table(name = "slow_query_history",
       indexes = @Index(name = "idx_fingerprint", columnList = "sqlFingerprint"))
public class SlowQueryHistory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // === 核心：SQL 指纹（唯一标识） ===
    @Column(length = 64, unique = true, nullable = false)
    private String sqlFingerprint;

    // 参数化后的 SQL 模板
    @Column(columnDefinition = "TEXT")
    private String sqlTemplate;

    // 最近一次捕获的具体 SQL（样本）
    @Column(columnDefinition = "TEXT")
    private String exampleSql;

    // === 基本信息 ===
    private String dbName;           // 所属数据库
    private String tableName;         // 涉及的表

    // === AI 分析结果 ===
    @Column(columnDefinition = "TEXT")
    private String aiAnalysisReport;  // AI 生成的报告（Markdown）

    // === 状态管理 ===
    @Enumerated(EnumType.STRING)
    private AnalysisStatus status;   // PENDING / SUCCESS / ERROR

    // === 统计信息（去重的关键） ===
    private Long occurrenceCount = 1L;       // 出现次数
    private LocalDateTime firstSeenTime;     // 首次发现时间
    private LocalDateTime lastSeenTime;      // 最近发现时间

    // === 元数据 ===
    private Double avgQueryTime;      // 平均查询耗时
    private Long maxRowsExamined;     // 最大扫描行数

    public enum AnalysisStatus {
        PENDING,   // 待分析
        SUCCESS,   // 已生成
        ERROR      // 失败
    }
}
```

### 4.2 Repository 接口（JPA）

```java
public interface SlowQueryHistoryRepository extends JpaRepository<SlowQueryHistory, Long> {

    // 根据 SQL 指纹查询（用于去重判断）
    Optional<SlowQueryHistory> findBySqlFingerprint(String sqlFingerprint);

    // 查询最常见的慢查询（按出现次数排序）
    List<SlowQueryHistory> findTop10ByOrderByOccurrenceCountDesc();

    // 查询最近新增的慢查询
    List<SlowQueryHistory> findTop10ByOrderByFirstSeenTimeDesc();

    // 查询指定状态的记录
    List<SlowQueryHistory> findByStatus(AnalysisStatus status);
}
```

---

## 五、SQL 指纹去重机制

### 5.1 什么是 SQL 指纹？

**SQL 指纹（Fingerprint）**：将参数化的 SQL 语句生成的唯一标识（MD5）

**示例**：
```sql
原始 SQL 1: SELECT * FROM orders WHERE user_id = 1
原始 SQL 2: SELECT * FROM orders WHERE user_id = 2
原始 SQL 3: SELECT * FROM orders WHERE user_id = 999

参数化后:    SELECT * FROM orders WHERE user_id = ?
指纹 MD5:    a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
```

**这三条 SQL 的指纹相同，视为同一类 SQL！**

### 5.2 使用 Druid 计算指纹

**依赖**（pom.xml）：
```xml
<!-- Druid (用于 SQL 解析和指纹计算) -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.20</version>
</dependency>

<!-- Hutool (MD5 计算) -->
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-all</artifactId>
    <version>5.8.20</version>
</dependency>
```

**工具类**（SqlFingerprintUtil.java）：
```java
import com.alibaba.druid.sql.SQLUtils;
import com.alibaba.druid.util.JdbcConstants;
import cn.hutool.core.util.SecureUtil;

public class SqlFingerprintUtil {

    /**
     * 计算 SQL 指纹
     *
     * @param rawSql 原始 SQL
     * @return MD5 哈希值
     */
    public static String calculateFingerprint(String rawSql) {
        // 1. Druid 格式化：把参数变成问号
        // "SELECT * FROM t WHERE id=1" → "SELECT * FROM t WHERE id=?"
        String sqlTemplate = SQLUtils.format(
            rawSql,
            JdbcConstants.MYSQL,
            SQLUtils.DEFAULT_FORMAT_OPTION
        );

        // 2. 计算 MD5 作为指纹
        return SecureUtil.md5(sqlTemplate);
    }

    /**
     * 提取 SQL 模板（参数化后的 SQL）
     */
    public static String extractTemplate(String rawSql) {
        return SQLUtils.format(
            rawSql,
            JdbcConstants.MYSQL,
            SQLUtils.DEFAULT_FORMAT_OPTION
        );
    }
}
```

### 5.3 去重逻辑流程

```java
@Service
public class AnalysisService {

    @Autowired
    private SlowQueryHistoryRepository historyRepo;

    public void processSlowQuery(SlowQueryLog slowLog) {
        String rawSql = slowLog.getSqlText();
        String dbName = slowLog.getDbName();

        // 1. 计算 SQL 指纹
        String fingerprint = SqlFingerprintUtil.calculateFingerprint(rawSql);

        // 2. 查询 H2：是否已存在？
        Optional<SlowQueryHistory> historyOpt = historyRepo.findBySqlFingerprint(fingerprint);

        if (historyOpt.isPresent()) {
            // === 情况 A：老面孔（已分析过） ===
            SlowQueryHistory history = historyOpt.get();
            handleExistingQuery(history, slowLog);
        } else {
            // === 情况 B：新面孔（首次发现） ===
            handleNewQuery(fingerprint, rawSql, dbName, slowLog);
        }
    }

    private void handleExistingQuery(SlowQueryHistory history, SlowQueryLog slowLog) {
        // 更新统计数据
        history.setOccurrenceCount(history.getOccurrenceCount() + 1);
        history.setLastSeenTime(LocalDateTime.now());
        history.setExampleSql(slowLog.getSqlText()); // 更新最新样本

        // 判断是否需要重新分析
        if (shouldReAnalyze(history)) {
            // 触发 AI 分析
            runAiAnalysis(history);
        } else {
            log.info("重复 SQL，跳过 AI 分析: fingerprint={}, count={}",
                history.getSqlFingerprint(), history.getOccurrenceCount());
        }

        historyRepo.save(history); // 保存到 H2
    }

    private void handleNewQuery(String fingerprint, String rawSql, String dbName, SlowQueryLog slowLog) {
        // 创建新记录
        SlowQueryHistory history = new SlowQueryHistory();
        history.setSqlFingerprint(fingerprint);
        history.setSqlTemplate(SqlFingerprintUtil.extractTemplate(rawSql));
        history.setExampleSql(rawSql);
        history.setDbName(dbName);
        history.setFirstSeenTime(LocalDateTime.now());
        history.setLastSeenTime(LocalDateTime.now());
        history.setStatus(AnalysisStatus.PENDING);
        history.setOccurrenceCount(1L);

        // 保存到 H2（本地数据库）
        history = historyRepo.save(history);

        // 触发 AI 分析
        runAiAnalysis(history);
    }

    private boolean shouldReAnalyze(SlowQueryHistory history) {
        // 重新分析条件：
        // 1. 上次分析失败
        if (history.getStatus() == AnalysisStatus.ERROR) {
            return true;
        }

        // 2. 距离首次发现超过 7 天
        if (history.getLastSeenTime().isAfter(
            history.getFirstSeenTime().plusDays(7)
        )) {
            return true;
        }

        return false;
    }
}
```

---

## 六、完整的数据流

### 6.1 轮询阶段

```
定时任务触发（每 60 秒）
    ↓
查询用户 MySQL（targetJdbcTemplate）
    ↓
SELECT * FROM mysql.slow_log WHERE start_time > ?
    ↓
提取慢查询数据（SlowQueryLog）
```

### 6.2 去重阶段

```
收到 SlowQueryLog
    ↓
计算 SQL 指纹（Druid + MD5）
    ↓
查询 H2 数据库（JPA Repository）
    ↓
判断指纹是否存在？
    ├─ 存在 → 更新计数 → 跳过分析
    └─ 不存在 → 创建新记录 → 触发分析
```

### 6.3 分析阶段

```
触发 AI 分析
    ↓
调用 LangChain4j Agent
    ↓
使用工具方法查询用户 MySQL：
    • EXPLAIN（执行计划）
    • SHOW CREATE TABLE（表结构）
    • information_schema（索引信息）
    ↓
生成分析报告（Markdown）
    ↓
保存报告到 H2
    ↓
发送通知（邮件、Webhook）
```

---

## 七、优势总结

### 7.1 零侵入
✅ 不在用户 MySQL 中创建任何表
✅ 只读权限访问 `information_schema` 和 `mysql.slow_log`
✅ 用户删除中间件目录即可完全卸载

### 7.2 智能去重
✅ 相同类型的 SQL 只分析一次
✅ 节省 AI Token 成本（高频 API 场景下尤其重要）
✅ 提高响应速度

### 7.3 历史记录
✅ 保存所有 AI 分析报告
✅ 支持 Dashboard 展示（Top 10 慢查询等）
✅ 统计分析（出现次数、首次/最近发现时间）

### 7.4 本地化存储
✅ 使用 H2 嵌入式数据库
✅ 数据存储为本地文件（`./data/db-doctor-internal.mv.db`）
✅ 无需额外安装数据库

---

## 八、依赖清单

```xml
<!-- H2 本地数据库 -->
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- Druid (SQL 解析和指纹计算) -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.20</version>
</dependency>

<!-- Hutool (MD5 计算) -->
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-all</artifactId>
    <version>5.8.20</version>
</dependency>

<!-- Spring Data JPA -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```

---

## 九、面试话术

**面试官问**："你的中间件需要侵入用户数据库建表吗？"

**你的回答**：
```
完全不需要，这是我架构设计的底线。

我采用了双数据源隔离架构：

1. 业务探针：使用只读权限的 JDBC 连接用户的 MySQL，
   仅用于执行 EXPLAIN 和读取 slow_log 系统表，
   做到了零侵入、零污染。

2. 自身状态：内嵌了一个 H2 数据库（File Mode）。
   所有经过 AI 分析生成的诊断报告、指纹去重数据，
   都保存在中间件部署目录下的本地文件中。

这样设计的好处是，用户删掉我的中间件文件夹，
就像什么都没发生过一样，不会在他们的生产库里留下任何垃圾表。
```

---

## 十、相关文件

### 配置类
- `TargetDataSourceConfig.java` - MySQL 目标数据源配置

### 实体类
- `SlowQueryHistory.java` - 分析历史实体（H2）

### Repository
- `SlowQueryHistoryRepository.java` - JPA Repository

### 服务类
- `SlowLogTableMonitor.java` - 慢查询表监控（轮询）
- `AnalysisService.java` - 分析服务（去重 + AI 调度）

### 工具类
- `SqlFingerprintUtil.java` - SQL 指纹计算工具
