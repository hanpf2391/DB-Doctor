# DB-Doctor 数据库连接与工具开发

## 一、开发目标

实现数据库连接层和 SQL 诊断工具箱，为 AI Agent 提供可调用的诊断工具方法。

## 二、功能描述

使用 Druid 连接池 + JdbcTemplate 实现数据库只读连接，并实现 6 个核心诊断工具方法，供 LangChain4j Agent 调用。

## 三、详细开发任务

### 3.1 数据库连接配置

#### 3.1.1 DataSource 配置

**位置**: `src/main/resources/application.yml`

```yaml
spring:
  datasource:
    # Druid 连接池配置
    type: com.alibaba.druid.pool.DruidDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/information_schema?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai
    username: db_doctor
    password: your_password
    # 只读模式配置（重要！）
    druid:
      read-only: true
      # 连接池参数
      initial-size: 2
      min-idle: 2
      max-active: 10
      max-wait: 60000
      test-on-borrow: false
      test-on-return: false
      test-while-idle: true
      validation-query: SELECT 1
      time-between-eviction-runs-millis: 60000
```

**注意**：
- 连接到 `information_schema` 或用户数据库都可以
- 使用只读账户（权限：SELECT, SHOW VIEW）
- 禁止配置写权限账户

#### 3.1.2 JdbcTemplate Bean

创建配置类：
```java
@Bean
public JdbcTemplate jdbcTemplate(DataSource dataSource) {
    return new JdbcTemplate(dataSource);
}
```

### 3.2 SQL 诊断工具箱实现

**位置**: `src/main/java/com/dbdoctor/agent/tools/SqlDiagnosticsTools.java`

#### 3.2.1 类结构设计

```java
@Component
public class SqlDiagnosticsTools {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 工具方法列表...
}
```

#### 3.2.2 工具方法 1: getExecutionPlan

**功能**: 执行 EXPLAIN FORMAT=JSON，获取查询执行计划和成本

```java
@Tool("执行SQL的执行计划分析，返回JSON格式的详细执行信息")
public String getExecutionPlan(@P("数据库名") String database, @P("需要分析的SQL语句") String sql) {
    // 1. 安全检查：防止注入
    // 2. 在 SQL 中添加数据库名前缀（如果 SQL 中没有）
    // 3. 执行: EXPLAIN FORMAT=JSON FOR {sql}
    // 4. 返回: JSON 字符串
}
```

**关键点**：
- 必须传入 `database` 参数
- 需要处理多行 SQL
- 如果 SQL 中没有数据库名前缀，自动添加：`SELECT * FROM shop.orders` → `SELECT * FROM shop.orders`（如果已经有数据库名则不添加）
- 提取 `query_block.cost_info` 中的 `query_cost`
- 返回示例：
  ```json
  {
    "query_cost": "10.45",
    "table": "users",
    "type": "ref",
    "key": "idx_user_id",
    "rows": 100
  }
  ```

#### 3.2.3 工具方法 2: getTableSchema

**功能**: 获取表结构（字段类型、索引）

```java
@Tool("获取表的结构信息，包括字段类型、索引定义")
public String getTableSchema(@P("数据库名") String database, @P("表名") String tableName) {
    // 1. 方式 1：从 information_schema 查询
    // SELECT * FROM information_schema.TABLES WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?

    // 2. 方式 2：执行 SHOW CREATE TABLE（需要先 USE database）
    // USE {database};
    // SHOW CREATE TABLE {tableName};

    // 3. 返回: 建表语句（包含字段类型、索引定义）
}
```

**关键点**：
- 必须传入 `database` 参数（支持多数据库诊断）
- 优先使用 `information_schema` 查询（无需切换数据库）
- 如果使用 `SHOW CREATE TABLE`，需要先执行 `USE database`
- 返回示例：
  ```sql
  CREATE TABLE `users` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `user_id` varchar(50) DEFAULT NULL,
    `status` tinyint(4) DEFAULT '1',
    PRIMARY KEY (`id`),
    KEY `idx_user_id` (`user_id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  ```

#### 3.2.4 工具方法 3: getIndexSelectivity

**功能**: 计算索引选择性（基数占比）

```java
@Tool("获取表的索引选择性分析，计算索引基数")
public String getIndexSelectivity(@P("数据库名") String database, @P("表名") String tableName) {
    // 1. 从 information_schema.STATISTICS 查询
    // SELECT
    //   INDEX_NAME,
    //   COLUMN_NAME,
    //   CARDINALITY,
    //   (CARDINALITY / TABLE_ROWS) AS selectivity
    // FROM information_schema.STATISTICS s
    // JOIN information_schema.TABLES t ON s.TABLE_SCHEMA = t.TABLE_SCHEMA AND s.TABLE_NAME = t.TABLE_NAME
    // WHERE s.TABLE_SCHEMA = ? AND s.TABLE_NAME = ?
    // ORDER BY INDEX_NAME, SEQ_IN_INDEX

    // 2. 计算索引选择性: Cardinality / TableRows
    // 3. 返回: 索引分析结果
}
```

**关键点**：
- 必须传入 `database` 参数
- 从 `information_schema.STATISTICS` 查询（支持所有数据库）
- 选择性 = 基数 / 表总行数
- 越接近 1 表示选择性越好
- 返回示例：
  ```json
  {
    "table": "users",
    "indexes": [
      {
        "key_name": "PRIMARY",
        "column_name": "id",
        "cardinality": 1000000,
        "selectivity": 1.0
      },
      {
        "key_name": "idx_user_id",
        "column_name": "user_id",
        "cardinality": 500000,
        "selectivity": 0.5
      }
    ]
  }
  ```

#### 3.2.5 工具方法 4: getTableStatistics

**功能**: 查询表的统计信息更新时间，判断是否过期

```java
@Tool("获取表的统计信息，包括表行数和最后更新时间，用于判断统计信息是否过期")
public String getTableStatistics(@P("数据库名") String database, @P("表名") String tableName) {
    // 1. MySQL 8.0+ - 从 mysql.innodb_table_stats 查询
    // SELECT
    //   database_name,
    //   table_name,
    //   table_rows,
    //   last_update AS update_time
    // FROM mysql.innodb_table_stats
    // WHERE database_name = ? AND table_name = ?

    // 2. MySQL 5.7 - 从 information_schema.TABLES 查询
    // SELECT
    //   TABLE_SCHEMA AS database_name,
    //   TABLE_NAME AS table_name,
    //   TABLE_ROWS AS table_rows,
    //   UPDATE_TIME AS update_time
    // FROM information_schema.TABLES
    // WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?

    // 3. 返回: 表行数、统计信息更新时间
}
```

**关键点**：
- 必须传入 `database` 参数
- MySQL 版本差异：
  - **MySQL 8.0+**：查询 `mysql.innodb_table_stats`
  - **MySQL 5.7**：查询 `information_schema.TABLES`
- 不要使用 `DATABASE()` 函数（连接的是 information_schema）
- 返回示例：
  ```json
  {
    "table": "users",
    "table_rows": 1000000,
    "update_time": "2024-01-22 10:00:00",
    "is_stale": false
  }
  ```
- 如果 `update_time` 距离现在超过 7 天，建议 `ANALYZE TABLE`

#### 3.2.6 工具方法 5: getLockInfo

**功能**: 查询当前锁等待信息

```java
@Tool("查询InnoDB锁等待信息，排查锁阻塞问题")
public String getLockInfo() {
    // 1. 查询 information_schema.innodb_locks (MySQL 5.7)
    // 2. 或查询 information_schema.innodb_trx + sys.schema_table_lock_waits (MySQL 8.0+)
    // 3. 返回: 锁等待详情
}
```

**关键点**：
- MySQL 8.0 使用 `sys.schema_table_lock_waits`
- MySQL 5.7 使用 `information_schema.innodb_locks`
- 返回示例：
  ```json
  {
    "lock_waits": [],
    "blocking_trx_count": 0,
    "waiting_trx_count": 0
  }
  ```

#### 3.2.7 工具方法 6: compareSqlPerformance

**功能**: 对比优化前后 SQL 的执行成本

```java
@Tool("对比两条SQL的执行计划成本，只做EXPLAIN不真实执行")
public String compareSqlPerformance(@P("原始SQL") String oldSql,
                                   @P("优化后的SQL") String newSql) {
    // 1. EXPLAIN oldSql
    // 2. EXPLAIN newSql
    // 3. 对比 query_cost
    // 4. 返回: 对比结果
}
```

**关键点**：
- 只执行 EXPLAIN，不执行真实 SQL
- 对比 `query_cost` 和预计扫描行数
- 返回示例：
  ```json
  {
    "old_sql_cost": 1000.50,
    "new_sql_cost": 10.25,
    "improvement": "99.0%",
    "recommendation": "推荐使用优化后的SQL"
  }
  ```

### 3.3 SQL 注入防护

所有工具方法必须实现以下安全检查：

```java
private void validateSql(String sql) {
    // 1. 检查是否包含注释符
    // 2. 检查是否包含多语句
    // 3. 检查是否包含危险关键词（DROP, TRUNCATE, DELETE 等）
    // 4. 白名单：只允许 SELECT, SHOW, EXPLAIN, DESCRIBE
}
```

**允许的 SQL 类型**：
- `SELECT ...`
- `SHOW ...`
- `EXPLAIN ...`
- `DESCRIBE ...`

**禁止的 SQL 类型**：
- `DROP ...`
- `DELETE ...`
- `UPDATE ...`
- `INSERT ...`
- `TRUNCATE ...`
- `ALTER ...`

### 3.4 异常处理

```java
- 表不存在: 返回 "表 {tableName} 不存在"
- 权限不足: 返回 "缺少查询权限，请检查数据库账户权限"
- SQL 语法错误: 返回 "SQL 语法错误: {errorMsg}"
- 连接失败: 返回 "数据库连接失败: {errorMsg}"
```

### 3.5 单元测试

为每个工具方法编写单元测试：

```java
@SpringBootTest
class SqlDiagnosticsToolsTest {

    @Autowired
    private SqlDiagnosticsTools tools;

    @Test
    void testGetExecutionPlan() {
        String sql = "SELECT * FROM users WHERE id = 1";
        String result = tools.getExecutionPlan(sql);
        assertNotNull(result);
        assertTrue(result.contains("query_cost"));
    }

    // 其他测试...
}
```

## 四、验收标准

1. ✓ 数据库能够正常连接（使用只读账户）
2. ✓ 6 个工具方法全部实现且可被 LangChain4j 调用
3. ✓ 每个工具方法有清晰的 @Tool 注解和参数说明
4. ✓ SQL 注入防护有效
5. ✓ 异常情况有友好的错误提示
6. ✓ 单元测试覆盖所有工具方法

## 五、注意事项

1. **只读原则**: 所有工具方法只能执行 SELECT/SHOW/EXPLAIN
2. **性能考虑**: EXPLAIN 查询很快，但仍需设置超时（5秒）
3. **版本兼容**: 需兼容 MySQL 5.7 和 8.0+
4. **日志记录**: 每个工具调用都需记录日志，便于调试
