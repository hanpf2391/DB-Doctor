# DB-Doctor 系统性能预测报告 v2.1.0

> **报告生成时间**: 2026-01-27
> **系统版本**: v2.1.0
> **分析场景**: 假设 AI 分析平均耗时 30 秒

---

## 📊 执行摘要

本报告从多个维度对 DB-Doctor 系统进行性能预测分析，包括**吞吐量、并发能力、资源消耗、瓶颈识别**等关键指标。

### 核心结论

| 指标 | 低负载场景 | 中负载场景 | 高负载场景 |
|------|-----------|-----------|-----------|
| **慢查询处理能力** | 10 条/小时 | 60 条/小时 | 1200 条/小时 |
| **AI 分析并发能力** | 2 个/30秒 | 4 个/30秒 | 4 个/30秒 |
| **最大队列容量** | 50 条 | 50 条（满载） | 50 条（溢出） |
| **系统状态** | ✅ 完全流畅 | ✅ 正常运行 | ⚠️ 背压启动 |

---

## 1. 系统架构分析

### 1.1 核心组件

```
┌─────────────────────────────────────────────────────────────┐
│                    DB-Doctor 系统架构                        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────────┐      ┌─────────────────┐              │
│  │  SlowLogTable   │      │  AnalysisService│              │
│  │  Monitor        │──────>│  (同步处理)     │              │
│  │  (自适应轮询)    │      │                 │              │
│  └─────────────────┘      └────────┬────────┘              │
│                                      │                       │
│                                      v                       │
│                           ┌─────────────────┐              │
│                           │  H2 Database    │              │
│                           │  (存储历史记录)  │              │
│                           └────────┬────────┘              │
│                                    │                        │
│                                    v                        │
│                           ┌─────────────────┐              │
│                           │ AI Agent Pool   │              │
│                           │ (异步分析)      │              │
│                           │ core=2, max=4   │              │
│                           │ queue=50        │              │
│                           └─────────────────┘              │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 关键配置参数

| 配置项 | 当前值 | 说明 |
|--------|--------|------|
| **自适应轮询间隔** | 5-60秒 | 根据负载自动调整 |
| **基础检查间隔** | 5秒 | 每次检查是否需要轮询 |
| **每次最大拉取** | 100条 | 单次从 mysql.slow_log 读取 |
| **AI 分析线程池** | core=2, max=4 | 异步处理 AI 分析 |
| **队列容量** | 50 | 任务队列最大长度 |
| **拒绝策略** | CallerRunsPolicy | 背压机制 |

---

## 2. 性能计算模型

### 2.1 慢查询采集性能

#### 2.1.1 自适应轮询策略

系统根据最近 10 分钟的慢查询数量自动调整轮询频率：

```
高负载（>100条/10分钟）→ 5秒轮询
中负载（10-100条/10分钟）→ 15秒轮询
低负载（<10条/10分钟）→ 60秒轮询
```

#### 2.1.2 理论最大吞吐量

| 场景 | 轮询间隔 | 每次最大拉取 | 理论最大吞吐量 |
|------|---------|-------------|---------------|
| **高负载** | 5秒 | 100条 | **1200 条/分钟** |
| **中负载** | 15秒 | 100条 | **400 条/分钟** |
| **低负载** | 60秒 | 100条 | **100 条/分钟** |

#### 2.1.3 实际处理能力（考虑同步处理）

AnalysisService.processSlowQuery() 是**同步方法**，包含以下操作：

1. SQL 清洗：~1ms
2. 指纹计算：~2ms
3. 数据库查询（H2）：~5ms
4. 数据库更新/插入：~10ms

**单条慢查询处理耗时**: ~18ms

**实际吞吐量**（瓶颈在于同步处理）：

| 场景 | 理论最大 | 实际最大（考虑 18ms/条） |
|------|---------|------------------------|
| **高负载** | 1200 条/分钟 | 3333 条/分钟 ✅ 无瓶颈 |
| **中负载** | 400 条/分钟 | 3333 条/分钟 ✅ 无瓶颈 |
| **低负载** | 100 条/分钟 | 3333 条/分钟 ✅ 无瓶颈 |

> ✅ **结论**: 慢查询采集模块无瓶颈，可轻松应对任何负载。

---

### 2.2 AI 分析并发性能

#### 2.2.1 线程池配置

```
核心线程数: 2
最大线程数: 4
队列容量: 50
拒绝策略: CallerRunsPolicy (背压)
```

#### 2.2.2 并发处理能力

**假设**: AI 分析平均耗时 30 秒（MockDBAgent.mock-delay-seconds）

| 线程数 | 并发处理能力 | 每小时处理量 | 每天处理量 |
|--------|------------|------------|-----------|
| **2 个（核心）** | 2 个/30秒 | **240 个** | **5,760 个** |
| **4 个（最大）** | 4 个/30秒 | **480 个** | **11,520 个** |
| **4 个 + 50 队列** | 54 个/批次 | **480 个/小时**（稳定） | **11,520 个** |

#### 2.2.3 队列缓冲能力

队列容量 50，可以缓冲 50 个待分析任务。

**队列满载时间**（在不同负载下）：

| 场景 | 慢查询速率 | 队列满载时间 |
|------|-----------|-------------|
| **低负载** | 10 条/小时 | **5 小时** |
| **中负载** | 60 条/小时 | **50 分钟** |
| **高负载** | 1200 条/小时 | **2.5 分钟** ⚠️ |

> ⚠️ **风险**: 高负载场景下，队列会快速满载，触发背压机制。

---

### 2.3 系统瓶颈分析

#### 2.3.1 吞吐量瓶颈

**瓶颈在 AI 分析阶段**，而非慢查询采集阶段。

| 阶段 | 最大吞吐量 | 是否瓶颈 |
|------|-----------|---------|
| 慢查询采集 | 3333 条/分钟 | ❌ 无瓶颈 |
| 同步处理（去重） | 3333 条/分钟 | ❌ 无瓶颈 |
| AI 分析（2 线程） | 4 个/分钟 | ✅ **瓶颈** |
| AI 分析（4 线程） | 8 个/分钟 | ✅ **瓶颈** |

#### 2.3.2 并发瓶颈

**最大并发能力**: 4 个 AI 分析任务（同时进行）

**背压触发条件**:
- 当慢查询速率 > 8 条/分钟时
- 队列会在 6 分钟内满载（50 ÷ 8 = 6.25 分钟）
- 之后触发 CallerRunsPolicy，阻塞主线程

---

## 3. 场景性能预测

### 3.1 低负载场景（<10 条/10分钟）

#### 业务场景
- 小型应用，偶发慢查询
- 例如：每天几次慢查询

#### 性能指标

| 指标 | 值 |
|------|-----|
| 慢查询速率 | 10 条/小时 |
| 轮询间隔 | 60 秒 |
| AI 分析并发 | 0-1 个 |
| 队列堆积 | 0-1 个 |
| CPU 使用率 | <5% |
| 内存使用 | <200MB |

#### 系统状态
✅ **完全流畅**，资源占用极低，队列几乎为空。

---

### 3.2 中负载场景（10-100 条/10分钟）

#### 业务场景
- 中型应用，周期性慢查询
- 例如：每小时 6-60 次慢查询

#### 性能指标

| 指标 | 值 |
|------|-----|
| 慢查询速率 | 60 条/小时 |
| 轮询间隔 | 15 秒 |
| AI 分析并发 | 1-2 个 |
| 队列堆积 | 0-10 个 |
| CPU 使用率 | 10-20% |
| 内存使用 | 200-400MB |

#### 系统状态
✅ **正常运行**，核心线程池足够应对，队列有缓冲空间。

---

### 3.3 高负载场景（>100 条/10分钟）

#### 业务场景
- 大型应用，持续慢查询
- 例如：每分钟 2 次以上的慢查询

#### 性能指标

| 指标 | 值 |
|------|-----|
| 慢查询速率 | 1200 条/小时 |
| 轮询间隔 | 5 秒 |
| AI 分析并发 | 4 个（满载） |
| 队列堆积 | 50 个（满载） |
| CPU 使用率 | 40-60% |
| 内存使用 | 500-800MB |

#### 系统状态
⚠️ **背压启动**，队列满载后触发 CallerRunsPolicy：
- 新任务会由**主线程**执行（背压）
- 主线程阻塞，影响后续慢查询采集
- 可能导致延迟累积

#### 风险
- 🚨 **队列溢出**: 2.5 分钟后队列满载
- 🚨 **主线程阻塞**: 背压机制导致采集延迟
- 🚨 **延迟累积**: 处理延迟可能达到 15-30 分钟

---

## 4. 瞬时峰值场景

### 4.1 突发大量慢查询

#### 场景描述
- 在 1 分钟内突然出现 100 条慢查询
- 例如：批量数据导入、全表扫描

#### 系统行为

```
时间轴：
00:00 - 突发 100 条慢查询
       ↓
00:01 - 100 条任务进入队列（队列容量 50，溢出 50）
       ↓
00:01 - 触发 CallerRunsPolicy，主线程开始处理溢出任务
       ↓
00:01 - 4 个线程开始处理队列中的 50 条
       ↓
00:16 - 队列处理完毕（50 条 ÷ 4 线程 ÷ 2 分钟/条 ≈ 12.5 分钟）
       ↓
00:31 - 所有任务处理完毕（100 条 ÷ 4 线程 ÷ 2 分钟/条 ≈ 25 分钟）
```

#### 影响范围
- ✅ 数据不丢失（背压保证）
- ⚠️ 处理延迟：25-30 分钟
- ⚠️ 主线程阻塞：影响后续采集

---

### 4.2 瞬时过载场景

#### 场景描述
- 慢查询速率持续超过 AI 处理能力
- 例如：每分钟 20 条慢查询（处理能力 8 条/分钟）

#### 系统行为

```
输入速率: 20 条/分钟
处理速率: 8 条/分钟
累积速率: 12 条/分钟

队列变化：
00 分钟: 0 条
05 分钟: 60 条（溢出 10 条）
10 分钟: 120 条（溢出 70 条）
15 分钟: 180 条（溢出 130 条）
...
```

#### 后果
- 🚨 **雪崩效应**: 队列持续溢出，主线程持续阻塞
- 🚨 **系统不可用**: 最终导致系统无法响应

---

## 5. 资源消耗预测

### 5.1 CPU 使用率

| 场景 | AI 分析线程 | 主线程 | 总 CPU |
|------|-----------|--------|--------|
| **低负载** | 0-1 个（5%） | 主线程（1%） | **5-10%** |
| **中负载** | 2 个（10%） | 主线程（2%） | **15-20%** |
| **高负载** | 4 个（20%） | 主线程（10%，背压） | **40-60%** |

### 5.2 内存使用

| 组件 | 内存占用 | 说明 |
|------|---------|------|
| **H2 数据库** | ~50MB | 存储历史记录 |
| **线程池（4 线程）** | ~200MB | 每线程 ~50MB |
| **队列（50 任务）** | ~50MB | 每任务 ~1MB |
| **Spring 容器** | ~100MB | 框架开销 |
| **总计** | **~400MB** | 正常负载 |

高负载时（队列满 + 背压）: **~600-800MB**

### 5.3 磁盘 I/O

| 操作 | 频率 | 影响 |
|------|------|------|
| **H2 写入** | 每条慢查询 1 次 | 极低 |
| **H2 读取** | 每条慢查询 1 次 | 极低 |
| **日志写入** | 每条慢查询 1 次 | 低 |

> ✅ **结论**: 磁盘 I/O 无瓶颈。

---

## 6. 性能优化建议

### 6.1 短期优化（无需改代码）

#### 1. 调整线程池配置

```yaml
db-doctor:
  thread-pool:
    ai-analysis:
      core-size: 4      # 2 → 4（提升并发）
      max-size: 8       # 4 → 8（应对峰值）
      queue-capacity: 100  # 50 → 100（增强缓冲）
```

**效果**:
- 并发能力: 4 个/分钟 → 8 个/分钟
- 队列缓冲: 50 条 → 100 条
- 高负载场景: 2.5 分钟满载 → 5 分钟满载

#### 2. 调整每次拉取数量

```yaml
db-doctor:
  slow-log-monitor:
    max-records-per-poll: 50  # 100 → 50（减少瞬时压力）
```

**效果**: 降低瞬时峰值压力，避免队列突发满载。

---

### 6.2 中期优化（小改代码）

#### 1. 实现 AI 分析优先级队列

```java
// 根据 queryTime 排序，优先分析严重慢查询
PriorityQueue<SlowQueryTask> queue = new PriorityQueue<>(
    Comparator.comparingDouble(SlowQueryTask::getQueryTime).reversed()
);
```

**效果**: 确保重要慢查询优先处理。

#### 2. 实现批量分析

```java
// 将多条相似慢查询合并分析
List<SlowQueryLog> batch = groupByFingerprint(logs);
aiAgent.analyzeBatch(batch);
```

**效果**: 减少 AI 调用次数，提升吞吐量 30-50%。

---

### 6.3 长期优化（架构重构）

#### 1. 引入消息队列（Kafka/RabbitMQ）

```
SlowLogTableMonitor → Kafka → AnalysisService
                              ↓
                         AI Agent Pool
```

**效果**:
- ✅ 完全解耦采集和分析
- ✅ 消息队列提供持久化缓冲
- ✅ 水平扩展 AI 分析节点

#### 2. 实现 AI 分析分布式化

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Node 1      │    │ Node 2      │    │ Node 3      │
│ 4 threads   │    │ 4 threads   │    │ 4 threads   │
└─────────────┘    └─────────────┘    └─────────────┘
       ↓                  ↓                  ↓
    Kafka Topic (slow_query_topic)
```

**效果**:
- 并发能力: 4 个/分钟 → 12 个/分钟（3 节点）
- 线性扩展能力

---

## 7. 压力测试建议

### 7.1 测试场景

| 场景 | 慢查询速率 | 持续时间 | 验收标准 |
|------|-----------|---------|---------|
| **低负载** | 10 条/小时 | 24 小时 | CPU <10%, 队列 <5 |
| **中负载** | 60 条/小时 | 24 小时 | CPU <30%, 队列 <30 |
| **高负载** | 1200 条/小时 | 1 小时 | CPU <70%, 队列 ≤50 |
| **峰值测试** | 100 条/分钟 | 10 分钟 | 不崩溃, 数据不丢失 |

### 7.2 Mock 数据生成

```java
// 使用 MockDBAgent 模拟 AI 耗时
db-doctor:
  ai:
    mock-enabled: true
    mock-delay-seconds: 30  # 模拟真实 AI 耗时
```

### 7.3 监控指标

- ✅ 队列堆积: `ThreadPoolExecutor.getQueue().size()`
- ✅ 活跃线程数: `ThreadPoolExecutor.getActiveCount()`
- ✅ 拒绝任务数: 自定义 Metrics
- ✅ 处理延迟: 记录任务提交到完成的时间

---

## 8. 结论

### 8.1 系统能力总结

| 场景 | 稳定性 | 吞吐量 | 延迟 |
|------|--------|--------|------|
| **低负载** | ✅ 完全稳定 | 10 条/小时 | <1 秒 |
| **中负载** | ✅ 完全稳定 | 60 条/小时 | <1 分钟 |
| **高负载** | ⚠️ 背压启动 | 480 条/小时 | 15-30 分钟 |

### 8.2 瓶颈识别

1. **主要瓶颈**: AI 分析速度（30 秒/条）
2. **次要瓶颈**: 线程池大小（4 线程）
3. **潜在风险**: 高负载场景下的背压机制

### 8.3 最终建议

#### 短期（1 周内）
- ✅ 调整线程池配置: `core-size=4, max-size=8, queue-capacity=100`
- ✅ 降低单次拉取: `max-records-per-poll=50`

#### 中期（1 月内）
- ✅ 实现优先级队列
- ✅ 实现批量分析

#### 长期（3 月内）
- ✅ 引入 Kafka 消息队列
- ✅ 实现 AI 分析分布式化

---

## 附录 A: 性能计算公式

### A.1 吞吐量计算

```
吞吐量（条/小时）= (3600 秒) / (AI 耗时 + 系统开销)
                 = 3600 / 30
                 = 120 条/小时/线程
                 × 4 线程
                 = 480 条/小时
```

### A.2 队列满载时间

```
满载时间（分钟）= 队列容量 / (输入速率 - 处理速率)

高负载场景:
= 50 / (20 - 8)
= 50 / 12
= 4.17 分钟
```

### A.3 背压触发条件

```
触发条件:
队列大小 = 队列容量 AND 活跃线程数 = 最大线程数

即:
getQueue().size() == 50 && getActiveCount() == 4
```

---

**报告结束**

如有任何问题或需要进一步分析，请联系 DB-Doctor 开发团队。
