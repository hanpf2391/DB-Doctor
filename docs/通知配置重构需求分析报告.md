# DB-Doctor 通知配置系统重构需求分析报告

**文档版本**: v2.0（简化版 - 仅批量聚合通知）
**编写日期**: 2026-02-07
**作者**: DB-Doctor 开发团队

---

## 一、现状分析

### 1.1 后端实现现状

#### 1.1.1 核心通知系统：NotifyService（批量聚合通知）

**文件位置**: `com.dbdoctor.service.NotifyService`

**触发方式**: 定时任务触发，通过 Cron 表达式控制执行频率

**核心功能**:
- 聚合一定时间范围内的所有告警记录
- 生成批量报告邮件
- 统一发送给配置的收件人列表

**当前配置来源**: `@Value` 注解读取 `application.yml`
```yaml
db-doctor:
  notify:
    email:
      to[]:                      # 收件人列表（主要接收人）
        - hpengfei0@gmail.com
      cc[]:                      # 抄送列表（可选）
        - team@example.com
      from: DB-Doctor <noreply@dbdoctor.com>  # 发件人
```

**SMTP 配置**: Spring Boot 标准配置
```yaml
spring:
  mail:
    host: smtp.qq.com
    port: 587
    username: 2391303768@qq.com
    password: ***
    properties:
      mail:
        smtp:
          auth: true
          starttls.enable: true
```

#### 1.1.2 定时调度配置：NotificationScheduleService

**文件位置**: `com.dbdoctor.service.NotificationScheduleService`

**核心功能**:
- 配置批量通知的 Cron 表达式（控制何时发送）
- 配置参与批量通知的渠道（EMAIL、钉钉、飞书等）
- 支持手动触发批量通知
- 支持热更新（修改配置后立即生效，无需重启）

**当前配置键**:
```yaml
notification.batch-cron: "0 0 * * * ?"           # Cron 表达式（默认每小时）
notification.enabled-channels: "EMAIL"            # 启用的通知渠道
```

**Cron 表达式示例**:
- `0 0 * * * ?` - 每小时
- `0 0 */2 * * ?` - 每 2 小时
- `0 0 9 * * ?` - 每天上午 9 点
- `0 0 9,18 * * ?` - 每天 9 点和 18 点

#### 1.1.3 告警策略配置（与通知分离）

**文件位置**: `com.dbdoctor.config.DbDoctorProperties`

**配置项**:
```yaml
notify:
  enabled-notifiers: email           # 启用的通知渠道
  notify-interval: 3600              # 通知间隔（秒）
  severity-threshold: 3.0            # 严重程度阈值（秒）
  cool-down-hours: 24                # 冷却时间（小时）
  degradation-multiplier: 1.5        # 性能恶化倍率
```

**说明**: 这些参数控制"何时满足告警条件"，与"如何发送通知"是两个独立的关注点。

---

### 1.2 前端配置界面现状

#### 1.2.1 当前配置界面结构

```
设置中心
├── 基础配置
├── 通知设置 ← 当前存在配置问题
│   ├── 邮件通知
│   │   ├── SMTP 服务器
│   │   ├── 端口
│   │   ├── 用户名
│   │   ├── 密码
│   │   ├── 发件人
│   │   ├── 严重收件人  ❌ 后端 NotifyService 不使用此配置
│   │   └── 警告收件人  ❌ 后端 NotifyService 不使用此配置
│   ├── 钉钉通知
│   ├── 飞书通知
│   ├── 企业微信通知
│   └── 定时批量通知配置（✅ 存在但配置键不匹配）
│       ├── Cron 表达式
│       └── 启用渠道
└── 告警设置
    ├── 严重程度阈值
    ├── 冷却时间
    └── 性能恶化倍率
```

#### 1.2.2 前后端配置映射问题

| 前端配置项 | 后端对应配置 | 状态 | 说明 |
|-----------|------------|------|------|
| `recipients_CRITICAL` | ❌ 不存在 | 删除 | EmailNotifier 专用，已废弃 |
| `recipients_WARNING` | ❌ 不存在 | 删除 | EmailNotifier 专用，已废弃 |
| `recipients_INFO` | ❌ 不存在 | 删除 | EmailNotifier 专用，已废弃 |
| `to`（批量通知收件人）| `db-doctor.notify.email.to[]` | ❌ 前端缺失 | **需添加** |
| `cc`（批量通知抄送） | `db-doctor.notify.email.cc[]` | ❌ 前端缺失 | **需添加** |
| SMTP 配置 | `spring.mail.*` | ❌ 前端缺失 | **需添加** |
| `batchCron` | `notification.batch-cron` | ✅ 存在 | 配置键已匹配 |
| `enabledChannels` | `notification.enabled-channels` | ✅ 存在 | 配置键已匹配 |

---

### 1.3 核心问题总结

#### 问题 1: 配置结构混乱
- ❌ 前端配置了"严重收件人"和"警告收件人"，但后端 NotifyService 不使用这些配置
- ❌ 缺少批量通知的核心收件人配置（`to`、`cc`）
- ❌ SMTP 配置在前端缺失

#### 问题 2: 配置存储不统一
- ❌ 后端使用 `@Value` 直接读取配置文件（无法动态修改）
- ❌ 前端保存到 `system_config` 表（但后端不读取）
- ❌ 缺少配置热重载机制（NotificationScheduleService 除外）

#### 问题 3: 功能边界不清晰
- ❌ "告警设置" tab 中的参数实际上控制告警触发条件，而非通知发送方式
- ❌ "通知设置"应该只关注"如何发送"，不应混合"何时触发"

---

## 二、重构目标

### 2.1 简化后的通知模型

**核心理念**: 只保留批量聚合通知，移除实时通知功能。

```
通知设置（统一入口，仅关注"如何发送"）
│
├── 通知渠道配置
│   ├── 启用邮件通知 [switch]
│   ├── 启用钉钉通知 [switch]
│   ├── 启用飞书通知 [switch]
│   └── 启用企业微信通知 [switch]
│
├── 邮件通知配置
│   ├── SMTP 服务器配置
│   │   ├── SMTP 服务器
│   │   ├── 端口
│   │   ├── 用户名
│   │   ├── 密码
│   │   └── [测试连接] 按钮
│   ├── 发件人设置
│   │   └── 发件人邮箱（支持显示名称）
│   ├── 收件人配置
│   │   ├── 收件人列表 (TO): [email1, email2]  ← 批量报告主要接收人
│   │   └── 抄送列表 (CC): [email1, email2]    ← 批量报告抄送人
│   └── [发送测试邮件] 按钮
│
├── 钉钉通知配置
│   ├── Webhook URL
│   └── 加签密钥
│
├── 飞书通知配置
│   └── Webhook URL
│
└── 企业微信通知配置
    └── Webhook URL
```

**定时批量通知配置**（独立模块，关注"何时发送"）
```
定时批量通知配置
│
├── Cron 表达式
│   ├── 预设选项：
│   │   ○ 每小时
│   │   ○ 每 2 小时
│   │   ○ 每 6 小时
│   │   ○ 每天 9 点
│   │   ○ 每天 18 点
│   │   ○ 每天 9 点和 18 点
│   │   └ ○ 自定义
│   └── 下次执行时间: 2026-02-07 15:00:00
│
├── 启用渠道（多选）
│   ☑ 邮件
│   ☐ 钉钉
│   ☐ 飞书
│   ☐ 企业微信
│
└── 操作
    ├── [立即触发一次] 按钮
    └── [查看上次执行日志] 按钮
```

---

### 2.2 配置动态化目标

- ✅ 所有配置保存到 `system_config` 表
- ✅ 后端从数据库读取配置（支持热重载）
- ✅ 修改配置后立即生效（无需重启应用）

---

### 2.3 配置验证目标

- ✅ SMTP 连接测试
- ✅ Webhook 可用性测试
- ✅ 收件人邮箱格式验证
- ✅ Cron 表达式合法性验证

---

## 三、技术方案设计

### 3.1 数据库配置存储

#### 3.1.1 配置键命名规范

```sql
-- ========== 通知渠道配置 ==========
notify.email.enabled                    -- 邮件通知开关
notify.dingtalk.enabled                 -- 钉钉通知开关
notify.feishu.enabled                   -- 飞书通知开关
notify.wecom.enabled                    -- 企业微信通知开关

-- ========== 邮件 SMTP 配置 ==========
mail.smtp.host                          -- SMTP 服务器（如 smtp.qq.com）
mail.smtp.port                          -- SMTP 端口（如 587）
mail.smtp.username                      -- SMTP 用户名
mail.smtp.password                      -- SMTP 密码（加密存储）
mail.smtp.from                          -- 发件人邮箱（仅邮箱地址，如 noreply@dbdoctor.com）
mail.smtp.display-name                  -- 发件人显示名称（默认 "DB-Doctor"）

-- ========== 批量报告收件人配置 ==========
mail.batch.to                           -- 收件人列表（逗号分隔）
mail.batch.cc                           -- 抄送列表（逗号分隔，可选）

-- ========== 钉钉通知配置 ==========
dingtalk.webhook                        -- Webhook URL
dingtalk.secret                         -- 加签密钥（可选）

-- ========== 飞书通知配置 ==========
feishu.webhook                          -- Webhook URL

-- ========== 企业微信通知配置 ==========
wecom.webhook                           -- Webhook URL

-- ========== 定时批量通知配置 ==========
notification.batch-cron                 -- Cron 表达式（如 "0 0 * * * ?"）
notification.enabled-channels           -- 启用的批量通知渠道（逗号分隔）
```

#### 3.1.2 配置数据示例

```yaml
# system_config 表数据示例
config_key                           | config_value
-------------------------------------|--------------------------------------
# 通知渠道开关
notify.email.enabled                  | true
notify.dingtalk.enabled               | true
notify.feishu.enabled                 | false
notify.wecom.enabled                  | false

# SMTP 配置
mail.smtp.host                        | smtp.qq.com
mail.smtp.port                        | 587
mail.smtp.username                    | 2391303768@qq.com
mail.smtp.password                    | [加密]
mail.smtp.from                        | noreply@dbdoctor.com
mail.smtp.display-name                | DB-Doctor

# 批量报告收件人
mail.batch.to                         | hpengfei0@gmail.com,team@example.com
mail.batch.cc                         | manager@example.com

# 钉钉配置
dingtalk.webhook                      | https://oapi.dingtalk.com/robot/send...
dingtalk.secret                       | SEC...

# 定时批量通知配置
notification.batch-cron               | 0 0 9,18 * * ?
notification.enabled-channels         | EMAIL,DINGTALK
```

---

### 3.2 后端重构方案

#### 3.2.1 配置读取机制

**现状**:
```java
// NotifyService 当前从配置文件读取
@Value("${db-doctor.notify.email.to:}")
private List<String> toEmails;

@Value("${db-doctor.notify.email.cc:}")
private List<String> ccEmails;
```

**目标**:
```java
@Service
public class NotifyService {

    private final SystemConfigService configService;

    /**
     * 发送批量通知邮件
     */
    public void sendBatchNotification(List<AlertHistory> alerts) {
        // 从数据库读取配置
        boolean enabled = configService.getBoolean("notify.email.enabled", false);
        if (!enabled) {
            log.info("[批量通知] 邮件通知未启用");
            return;
        }

        // 读取收件人配置
        List<String> toEmails = configService.getList("mail.batch.to");
        List<String> ccEmails = configService.getList("mail.batch.cc");

        if (toEmails.isEmpty()) {
            log.warn("[批量通知] 未配置收件人");
            return;
        }

        // 构造发件人（包装为 "DB-Doctor <noreply@dbdoctor.com>" 格式）
        String fromEmail = configService.getString("mail.smtp.from");
        String displayName = configService.getString("mail.smtp.display-name", "DB-Doctor");
        String from = String.format("%s <%s>", displayName, fromEmail);

        // 发送邮件...
    }
}
```

#### 3.2.2 配置热重载

**实现方式**:
```java
@Service
public class ConfigHotReloadService {

    @Autowired
    private SystemConfigService configService;

    @Autowired
    private NotifyService notifyService;

    /**
     * 配置变更事件监听
     */
    @EventListener
    public void onConfigChanged(ConfigChangedEvent event) {
        String configKey = event.getConfigKey();

        // 如果修改了邮件相关配置，重新加载
        if (configKey.startsWith("mail.") || configKey.startsWith("notify.")) {
            log.info("[配置热重载] 检测到邮件配置变更，重新加载");
            notifyService.reloadConfig();
        }

        // 如果修改了定时通知配置，重新调度任务
        if (configKey.startsWith("notification.")) {
            log.info("[配置热重载] 检测到定时通知配置变更，重新调度任务");
            dynamicScheduleService.scheduleOrUpdateTask();
        }
    }
}
```

#### 3.2.3 发件人邮箱处理逻辑

**设计原则**:
- **前端**: 用户只需填写纯邮箱地址（如 `noreply@dbdoctor.com`）
- **后端**: 自动包装为标准格式（如 `DB-Doctor <noreply@dbdoctor.com>`）
- **配置**: 分离存储邮箱地址和显示名称

**实现方式**:
```java
@Service
public class EmailService {

    @Autowired
    private SystemConfigService configService;

    /**
     * 获取发件人邮箱（自动包装格式）
     *
     * @return 格式: "DB-Doctor <noreply@dbdoctor.com>"
     */
    private String getFromEmail() {
        String fromEmail = configService.getString("mail.smtp.from");
        String displayName = configService.getString("mail.smtp.display-name", "DB-Doctor");

        // 自动包装为 "显示名称 <邮箱地址>" 格式
        return String.format("%s <%s>", displayName, fromEmail);
    }

    /**
     * 验证发件人邮箱格式
     */
    private void validateFromEmail(String email) {
        if (email == null || email.trim().isEmpty()) {
            throw new IllegalArgumentException("发件人邮箱不能为空");
        }

        // 验证是否为纯邮箱格式（不包含显示名称）
        if (email.contains("<") || email.contains(">")) {
            throw new IllegalArgumentException("发件人邮箱请填写纯邮箱地址，系统会自动添加显示名称");
        }

        // 邮箱格式验证
        if (!email.matches("^[A-Za-z0-9+_.-]+@(.+)$")) {
            throw new IllegalArgumentException("发件人邮箱格式不正确");
        }
    }
}
```

**前端配置保存逻辑**:
```typescript
async function saveEmailConfig() {
  const configs = {
    // 前端只保存纯邮箱地址和显示名称
    'mail.smtp.from': emailConfig.smtp.from,          // 'noreply@dbdoctor.com'
    'mail.smtp.display-name': emailConfig.smtp.displayName || 'DB-Doctor'
  }

  await notificationConfigAPI.updateConfigs({ configs })
}
```

**后端发送邮件时**:
```java
// 使用 JavaMailSender 发送邮件
MimeMessage message = mailSender.createMimeMessage();
MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");

// 设置发件人（已包装好的格式）
helper.setFrom(getFromEmail());  // "DB-Doctor <noreply@dbdoctor.com>"
helper.setTo(toEmails.toArray(new String[0]));
helper.setCc(ccEmails.toArray(new String[0]));
helper.setSubject("DB-Doctor 批量报告");
```

#### 3.2.4 统一的配置 API

```java
@RestController
@RequestMapping("/api/notification-config")
public class NotificationConfigController {

    /**
     * 获取所有通知配置
     */
    @GetMapping
    public Map<String, Object> getAllConfigs() {
        Map<String, Object> result = new HashMap<>();

        // 通知渠道开关
        result.put("emailEnabled", configService.getBoolean("notify.email.enabled", false));
        result.put("dingtalkEnabled", configService.getBoolean("notify.dingtalk.enabled", false));

        // SMTP 配置
        result.put("smtpHost", configService.getString("mail.smtp.host"));
        result.put("smtpPort", configService.getInteger("mail.smtp.port"));
        result.put("smtpUsername", configService.getString("mail.smtp.username"));
        result.put("smtpFrom", configService.getString("mail.smtp.from"));

        // 收件人配置
        result.put("batchTo", configService.getList("mail.batch.to"));
        result.put("batchCc", configService.getList("mail.batch.cc"));

        // 钉钉配置
        result.put("dingtalkWebhook", configService.getString("dingtalk.webhook"));

        return result;
    }

    /**
     * 批量更新配置
     */
    @PostMapping
    public Map<String, Object> updateConfigs(@RequestBody Map<String, String> configs) {
        // 1. 验证配置
        validateConfigs(configs);

        // 2. 保存到数据库
        configService.batchUpdate(configs);

        // 3. 触发热重载
        eventPublisher.publishEvent(new ConfigChangedEvent(configs));

        return Map.of("code", "SUCCESS", "message", "配置保存成功并立即生效");
    }

    /**
     * 测试 SMTP 连接
     */
    @PostMapping("/test/smtp")
    public void testSmtpConnection(@RequestBody SmtpConfig smtpConfig) {
        mailService.testConnection(smtpConfig);
    }

    /**
     * 发送测试邮件
     */
    @PostMapping("/test/email")
    public void sendTestEmail(@RequestBody TestEmailRequest request) {
        mailService.sendTestEmail(request.getTo(), request.getSubject());
    }
}
```

---

### 3.3 前端界面重构方案

#### 3.3.1 页面结构设计（简化版）

```vue
<template>
  <div class="notification-settings">
    <!-- 通知渠道配置 -->
    <ConfigCard title="通知渠道" icon="Notification">
      <el-form label-width="120px">
        <el-form-item label="启用邮件通知">
          <el-switch v-model="emailEnabled" />
        </el-form-item>

        <el-form-item label="启用钉钉通知">
          <el-switch v-model="dingtalkEnabled" />
        </el-form-item>

        <el-form-item label="启用飞书通知">
          <el-switch v-model="feishuEnabled" />
        </el-form-item>

        <el-form-item label="启用企业微信通知">
          <el-switch v-model="wecomEnabled" />
        </el-form-item>
      </el-form>
    </ConfigCard>

    <!-- 邮件通知配置 -->
    <ConfigCard title="邮件通知配置" icon="Message" v-if="emailEnabled">
      <el-form :model="emailConfig" label-width="120px">
        <!-- SMTP 配置 -->
        <el-divider content-position="left">SMTP 服务器</el-divider>

        <el-form-item label="SMTP 服务器" required>
          <el-input v-model="emailConfig.smtp.host" placeholder="smtp.qq.com" />
        </el-form-item>

        <el-form-item label="端口" required>
          <el-input-number v-model="emailConfig.smtp.port" :min="1" :max="65535" />
        </el-form-item>

        <el-form-item label="用户名" required>
          <el-input v-model="emailConfig.smtp.username" placeholder="your-email@qq.com" />
        </el-form-item>

        <el-form-item label="密码" required>
          <el-input v-model="emailConfig.smtp.password" type="password" show-password />
        </el-form-item>

        <el-form-item>
          <el-button @click="testSmtpConnection" :loading="testing.smtp">
            <el-icon><Connection /></el-icon> 测试连接
          </el-button>
        </el-form-item>

        <!-- 发件人配置 -->
        <el-divider content-position="left">发件人设置</el-divider>

        <el-form-item label="发件人邮箱" required>
          <el-input v-model="emailConfig.smtp.from" placeholder="noreply@dbdoctor.com" />
          <span class="help-text">仅填写邮箱地址，系统会自动添加显示名称</span>
        </el-form-item>

        <el-form-item label="显示名称">
          <el-input v-model="emailConfig.smtp.displayName" placeholder="DB-Doctor" />
          <span class="help-text">邮件发件人的显示名称，默认为 "DB-Doctor"</span>
        </el-form-item>

        <el-form-item label="预览格式">
          <el-tag type="info">{{ emailConfig.smtp.displayName || 'DB-Doctor' }} &lt;{{ emailConfig.smtp.from || 'noreply@dbdoctor.com' }}&gt;</el-tag>
        </el-form-item>

        <!-- 批量报告收件人 -->
        <el-divider content-position="left">批量报告收件人</el-divider>

        <el-form-item label="收件人 (TO)" required>
          <el-select
            v-model="emailConfig.batch.to"
            multiple
            filterable
            allow-create
            placeholder="选择或输入邮箱地址"
          >
            <el-option
              v-for="email in emailConfig.batch.to"
              :key="email"
              :label="email"
              :value="email"
            />
          </el-select>
          <span class="help-text">批量报告的主要接收人</span>
        </el-form-item>

        <el-form-item label="抄送 (CC)">
          <el-select
            v-model="emailConfig.batch.cc"
            multiple
            filterable
            allow-create
            placeholder="选择或输入邮箱地址（可选）"
          >
            <el-option
              v-for="email in emailConfig.batch.cc"
              :key="email"
              :label="email"
              :value="email"
            />
          </el-select>
          <span class="help-text">批量报告的抄送人（可选）</span>
        </el-form-item>

        <el-form-item>
          <el-button type="primary" @click="sendTestEmail">
            <el-icon><Promotion /></el-icon> 发送测试邮件
          </el-button>
        </el-form-item>
      </el-form>
    </ConfigCard>

    <!-- 钉钉通知配置 -->
    <ConfigCard title="钉钉通知配置" icon="ChatDotRound" v-if="dingtalkEnabled">
      <el-form :model="dingtalkConfig" label-width="120px">
        <el-form-item label="Webhook URL" required>
          <el-input v-model="dingtalkConfig.webhook" placeholder="https://oapi.dingtalk.com/robot/..." />
        </el-form-item>

        <el-form-item label="加签密钥">
          <el-input v-model="dingtalkConfig.secret" type="password" show-password />
        </el-form-item>
      </el-form>
    </ConfigCard>
  </div>
</template>
```

#### 3.3.2 定时批量通知配置页面（独立）

```vue
<template>
  <div class="schedule-config">
    <ConfigCard title="定时批量通知配置" icon="Clock">
      <el-form :model="scheduleConfig" label-width="120px">
        <!-- Cron 表达式配置 -->
        <el-form-item label="执行频率">
          <el-radio-group v-model="scheduleConfig.cronPreset" @change="onCronPresetChange">
            <el-radio label="0 0 * * * ?">每小时</el-radio>
            <el-radio label="0 0 */2 * * ?">每 2 小时</el-radio>
            <el-radio label="0 0 */6 * * ?">每 6 小时</el-radio>
            <el-radio label="0 0 9 * * ?">每天 9 点</el-radio>
            <el-radio label="0 0 18 * * ?">每天 18 点</el-radio>
            <el-radio label="0 0 9,18 * * ?">每天 9 点和 18 点</el-radio>
            <el-radio label="custom">自定义</el-radio>
          </el-radio-group>
        </el-form-item>

        <el-form-item label="Cron 表达式" v-if="scheduleConfig.cronPreset === 'custom'">
          <el-input v-model="scheduleConfig.batchCron" placeholder="0 0 * * * ?" />
          <span class="help-text">Cron 表达式格式：秒 分 时 日 月 周</span>
        </el-form-item>

        <el-form-item label="下次执行">
          <el-tag type="info">{{ scheduleConfig.nextExecutionTime }}</el-tag>
        </el-form-item>

        <!-- 启用渠道配置 -->
        <el-form-item label="启用渠道">
          <el-checkbox-group v-model="scheduleConfig.enabledChannels">
            <el-checkbox label="EMAIL">邮件</el-checkbox>
            <el-checkbox label="DINGTALK">钉钉</el-checkbox>
            <el-checkbox label="FEISHU">飞书</el-checkbox>
            <el-checkbox label="WECOM">企业微信</el-checkbox>
          </el-checkbox-group>
          <span class="help-text">选择参与批量通知的渠道</span>
        </el-form-item>

        <!-- 操作按钮 -->
        <el-form-item>
          <el-button type="primary" @click="saveScheduleConfig" :loading="saving">
            保存配置
          </el-button>
          <el-button @click="triggerNow" :loading="triggering">
            立即触发一次
          </el-button>
        </el-form-item>
      </el-form>
    </ConfigCard>
  </div>
</template>
```

#### 3.3.3 数据结构设计（TypeScript）

```typescript
// 通知渠道配置
interface NotificationChannelsConfig {
  emailEnabled: boolean
  dingtalkEnabled: boolean
  feishuEnabled: boolean
  wecomEnabled: boolean
}

// 邮件配置
interface EmailConfig {
  enabled: boolean
  smtp: {
    host: string           // 'smtp.qq.com'
    port: number           // 587
    username: string       // '2391303768@qq.com'
    password: string       // '***'
    from: string           // 'noreply@dbdoctor.com'（仅邮箱地址）
    displayName: string    // 'DB-Doctor'（显示名称，默认值）
  }
  batch: {
    to: string[]          // ['hpengfei0@gmail.com', 'team@example.com']
    cc: string[]          // ['manager@example.com']
  }
}

// 钉钉配置
interface DingTalkConfig {
  enabled: boolean
  webhook: string         // 'https://oapi.dingtalk.com/robot/...'
  secret: string          // 'SEC...'
}

// 定时批量通知配置
interface ScheduleConfig {
  batchCron: string       // '0 0 9,18 * * ?'
  cronPreset: string     // '0 0 9,18 * * ?' | 'custom'
  enabledChannels: string[]  // ['EMAIL', 'DINGTALK']
  nextExecutionTime: string  // '2026-02-07 18:00:00'
}

// 保存配置的数据格式
interface SaveConfigRequest {
  configs: {
    [key: string]: string
  }
}
```

---

## 四、实施计划

### 4.1 Phase 1: 数据库配置准备（1 天）

**任务**:
1. 准备配置数据初始化 SQL 脚本
2. 从现有 `application.yml` 迁移配置到数据库
3. 编写配置初始化类 `NotificationConfigInitializer`

**配置初始化 SQL**:
```sql
-- 通知渠道开关
INSERT INTO system_config (config_key, config_value, config_group, config_name, config_type, is_required, is_enabled, display_order)
VALUES
  ('notify.email.enabled', 'true', 'notification', '启用邮件通知', 'boolean', true, true, 1),
  ('notify.dingtalk.enabled', 'false', 'notification', '启用钉钉通知', 'boolean', true, true, 2),
  ('notify.feishu.enabled', 'false', 'notification', '启用飞书通知', 'boolean', true, true, 3),
  ('notify.wecom.enabled', 'false', 'notification', '启用企业微信通知', 'boolean', true, true, 4);

-- SMTP 配置
INSERT INTO system_config (config_key, config_value, config_group, config_name, config_type, is_required, is_sensitive, is_enabled, display_order)
VALUES
  ('mail.smtp.host', 'smtp.qq.com', 'mail', 'SMTP 服务器', 'string', true, false, true, 10),
  ('mail.smtp.port', '587', 'mail', 'SMTP 端口', 'integer', true, false, true, 11),
  ('mail.smtp.username', '2391303768@qq.com', 'mail', 'SMTP 用户名', 'string', true, false, true, 12),
  ('mail.smtp.password', '***', 'mail', 'SMTP 密码', 'string', true, true, true, 13),
  ('mail.smtp.from', 'noreply@dbdoctor.com', 'mail', '发件人邮箱', 'string', true, false, true, 14),
  ('mail.smtp.display-name', 'DB-Doctor', 'mail', '发件人显示名称', 'string', false, false, true, 15);

-- 批量报告收件人
INSERT INTO system_config (config_key, config_value, config_group, config_name, config_type, is_required, is_sensitive, is_enabled, display_order)
VALUES
  ('mail.batch.to', 'hpengfei0@gmail.com', 'mail', '批量报告收件人', 'string', true, true, true, 20),
  ('mail.batch.cc', '', 'mail', '批量报告抄送', 'string', false, true, true, 21);

-- 定时批量通知配置
INSERT INTO system_config (config_key, config_value, config_group, config_name, config_type, is_required, is_enabled, display_order)
VALUES
  ('notification.batch-cron', '0 0 9,18 * * ?', 'schedule', '批量通知 Cron 表达式', 'string', true, true, 30),
  ('notification.enabled-channels', 'EMAIL', 'schedule', '批量通知启用渠道', 'string', true, true, 31);
```

**验收标准**:
- ✅ `system_config` 表包含所有通知配置
- ✅ 后端能从数据库读取配置

---

### 4.2 Phase 2: 后端重构（2-3 天）

**任务**:
1. 重构 `NotifyService` 使用 `SystemConfigService`
2. 实现 `ConfigHotReloadService`
3. 统一 `NotificationConfigController`
4. 实现配置验证逻辑

**验收标准**:
- ✅ 后端不从 `@Value` 读取配置，全部从数据库读取
- ✅ 配置修改后立即生效（热重载）
- ✅ 提供完整的配置 CRUD API

---

### 4.3 Phase 3: 前端重构（2 天）

**任务**:
1. 重新设计"通知设置"页面结构（移除严重/警告收件人）
2. 实现"定时批量通知配置"页面（或作为独立区块）
3. 实现配置保存和加载逻辑
4. 实现测试连接和测试邮件功能

**验收标准**:
- ✅ 配置界面清晰易用
- ✅ 支持配置的增删改查
- ✅ 批量报告收件人配置正确（to、cc）

---

### 4.4 Phase 4: 测试验证（1 天）

**任务**:
1. 单元测试：配置加载、保存、验证
2. 集成测试：邮件发送、热重载
3. UI 测试：配置保存、表单验证

**验收标准**:
- ✅ 所有测试通过
- ✅ 覆盖率 ≥ 80%

---

### 4.5 Phase 5: 文档和部署（0.5 天）

**任务**:
1. 编写用户使用文档
2. 编写部署文档
3. 配置迁移指南

---

## 五、风险评估

### 5.1 技术风险

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| 配置热重载失败 | 高 | 中 | 保留 `@Value` 作为降级方案，增加重试机制 |
| 数据库性能影响 | 中 | 低 | 配置缓存 + 异步刷新 |
| 配置迁移失败 | 高 | 低 | 详细测试 + 回滚方案 |

---

### 5.2 业务风险

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| 用户配置错误导致通知失败 | 高 | 中 | 配置验证 + 测试发送功能 |
| 现有配置丢失 | 高 | 低 | 自动迁移脚本 + 备份 |

---

## 六、成功指标

### 6.1 功能指标

- ✅ 支持批量报告通知（邮件、钉钉、飞书、企业微信）
- ✅ 支持定时调度（Cron 表达式）
- ✅ 配置修改实时生效（无需重启）
- ✅ 提供配置验证和测试功能

---

### 6.2 性能指标

- ✅ 配置读取响应时间 < 100ms
- ✅ 配置热重载耗时 < 1s
- ✅ 邮件发送成功率 > 95%

---

### 6.3 易用性指标

- ✅ 配置界面清晰，用户能理解配置用途
- ✅ 提供完善的帮助提示和错误提示
- ✅ 支持配置测试，降低配置错误率

---

## 七、附录

### 7.1 配置字段对照表（简化版）

| 配置项 | 配置键 | 数据类型 | 默认值 | 说明 |
|--------|--------|---------|--------|------|
| **通知渠道开关** |
| 启用邮件通知 | notify.email.enabled | Boolean | false | - |
| 启用钉钉通知 | notify.dingtalk.enabled | Boolean | false | - |
| 启用飞书通知 | notify.feishu.enabled | Boolean | false | - |
| 启用企业微信通知 | notify.wecom.enabled | Boolean | false | - |
| **SMTP 配置** |
| SMTP 服务器 | mail.smtp.host | String | - | - |
| SMTP 端口 | mail.smtp.port | Integer | 587 | - |
| SMTP 用户名 | mail.smtp.username | String | - | - |
| SMTP 密码 | mail.smtp.password | String | - | 加密存储 |
| 发件人邮箱 | mail.smtp.from | String | noreply@dbdoctor.com | 仅邮箱地址 |
| 发件人显示名称 | mail.smtp.display-name | String | DB-Doctor | 后端自动包装 |
| **批量报告收件人** |
| 收件人 (TO) | mail.batch.to | String | - | 逗号分隔 |
| 抄送 (CC) | mail.batch.cc | String | - | 逗号分隔 |
| **钉钉配置** |
| Webhook URL | dingtalk.webhook | String | - | - |
| 加签密钥 | dingtalk.secret | String | - | 可选 |
| **定时批量通知配置** |
| Cron 表达式 | notification.batch-cron | String | 0 0 * * * ? | - |
| 启用渠道 | notification.enabled-channels | String | EMAIL | 逗号分隔 |

---

### 7.2 API 接口定义

#### 7.2.1 获取所有配置

```
GET /api/notification-config

Response:
{
  "code": 200,
  "data": {
    "notify.email.enabled": "true",
    "mail.smtp.host": "smtp.qq.com",
    "mail.batch.to": "hpengfei0@gmail.com,team@example.com",
    "notification.batch-cron": "0 0 9,18 * * ?",
    ...
  }
}
```

#### 7.2.2 批量更新配置

```
POST /api/notification-config

Request:
{
  "configs": {
    "notify.email.enabled": "true",
    "mail.smtp.host": "smtp.qq.com",
    "mail.batch.to": "hpengfei0@gmail.com,team@example.com",
    ...
  }
}

Response:
{
  "code": "SUCCESS",
  "message": "配置保存成功并立即生效"
}
```

#### 7.2.3 测试 SMTP 连接

```
POST /api/notification-config/test/smtp

Request:
{
  "host": "smtp.qq.com",
  "port": 587,
  "username": "2391303768@qq.com",
  "password": "***"
}

Response:
{
  "code": "SUCCESS",
  "message": "连接成功"
}
```

#### 7.2.4 发送测试邮件

```
POST /api/notification-config/test/email

Request:
{
  "to": ["test@example.com"],
  "subject": "DB-Doctor 测试邮件"
}

Response:
{
  "code": "SUCCESS",
  "message": "测试邮件已发送"
}
```

#### 7.2.5 获取/更新定时批量通知配置

```
GET /api/notification-schedule/config

Response:
{
  "batchCron": "0 0 9,18 * * ?",
  "enabledChannels": ["EMAIL", "DINGTALK"],
  "cronDescription": "每天 9 点和 18 点",
  "nextExecutionTime": "2026-02-07 18:00:00"
}

POST /api/notification-schedule/config

Request:
{
  "batchCron": "0 0 9,18 * * ?",
  "enabledChannels": ["EMAIL", "DINGTALK"]
}

Response:
{
  "code": "SUCCESS",
  "message": "配置已保存并立即生效"
}
```

#### 7.2.6 手动触发批量通知

```
POST /api/notification-schedule/trigger

Request:
{
  "reason": "手动测试"
}

Response:
{
  "code": "SUCCESS",
  "message": "定时任务已触发",
  "data": {
    "executionId": "uuid-xxx",
    "triggerTime": "2026-02-07T15:30:00",
    "reason": "手动测试"
  }
}
```

---

**报告结束**

---

## 版本历史

| 版本 | 日期 | 说明 |
|------|------|------|
| v1.0 | 2026-02-07 | 初始版本（包含 EmailNotifier 和 NotifyService） |
| **v2.0** | **2026-02-07** | **简化版本（仅保留 NotifyService 批量聚合通知）** |

---

*本报告详细分析了当前通知配置系统的问题，并提出了简化的重构方案。建议按照实施计划分阶段进行重构，确保系统稳定性和用户体验。*
