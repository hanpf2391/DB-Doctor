# DB-Doctor 监控与通知功能开发需求分析报告

**版本**: v1.0
**创建日期**: 2026-02-06
**文档类型**: 技术设计需求分析
**基于文档**: 全功能白皮书 v3.0.0

---

## 目录

1. [需求背景](#1-需求背景)
2. [现状分析](#2-现状分析)
3. [功能需求概述](#3-功能需求概述)
4. [后端设计](#4-后端设计)
5. [前端设计](#5-前端设计)
6. [数据库设计](#6-数据库设计)
7. [API 设计](#7-api-设计)
8. [实施计划](#8-实施计划)
9. [验收标准](#9-验收标准)

---

## 1. 需求背景

### 1.1 业务背景

DB-Doctor 作为 MySQL 慢查询智能诊疗系统，在运行过程中需要：

1. **实时监控**系统自身的健康状态和性能指标
2. **及时发现**系统异常和性能瓶颈
3. **自动告警**并将关键信息推送给运维人员
4. **支持多种通知渠道**（邮件、Webhook、钉钉、飞书、企业微信）

### 1.2 现状问题

根据白皮书第 9.2.1 节和第 10.1 节的分析：

| 问题 | 影响 | 优先级 |
|------|------|--------|
| `NotifyService.java:94` 通知逻辑未实现（TODO） | 无法发送告警 | **高** |
| 缺少系统健康监控 | 无法感知系统状态 | **高** |
| 缺少实时告警机制 | 异常发现不及时 | **高** |
| AI 监控已有，但缺少业务监控 | 监控维度不全 | **中** |
| 缺少告警历史记录 | 无法追溯告警历史 | **中** |

### 1.3 目标

构建一个**企业级监控与告警系统**，实现：

- ✅ 全方位系统监控（健康、性能、业务）
- ✅ 智能告警机制（阈值、异常、趋势）
- ✅ 多渠道通知推送（邮件、Webhook、IM）
- ✅ 告警历史管理与追溯
- ✅ 灵活的通知策略配置
- ✅ 友好的前端可视化界面

---

## 2. 现状分析

### 2.1 已有功能（白皮书 3.1 节）

| 模块 | 功能 | 状态 |
|------|------|------|
| **AI 监控** | | |
| AI 调用监听 | `AiMonitoringListener.java` | ✅ 已实现 |
| Token 统计 | `AiMonitoringListener.java:125-167` | ✅ 已实现 |
| 成本分析 | `AiCostService.java` | ✅ 已实现 |
| 错误分类 | `AiErrorCategory.java` | ✅ 已实现 |
| 数据清理 | `MonitorDataCleanupJob.java` | ✅ 已实现 |
| **通知服务** | | |
| 通知判断 | `SlowQueryTemplate.shouldNotify()` | ✅ 已实现 |
| 定时批量通知 | `NotificationScheduler.java` | ✅ 已实现 |
| 邮件通知 | `NotifyService.java` | ❌ TODO |
| Webhook 通知 | `NotifyService.java` | ❌ TODO |
| **前端监控** | | |
| AI 监控面板 | `AiMonitor/index.vue` | ✅ 已实现 |
| 调用日志 | `AiMonitor/InvocationLog.vue` | ✅ 已实现 |
| 成本分析 | `AiMonitor/CostAnalysis.vue` | ✅ 已实现 |

### 2.2 待补充功能

```
┌─────────────────────────────────────────────────────────────────┐
│                    待补充的监控与通知功能                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【后端】                                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 1. 系统健康监控                                          │   │
│  │    ✓ 服务健康状态（启动时间、版本、JVM）                 │   │
│  │    ✓ 数据源连接状态（H2、MySQL）                        │   │
│  │    ✓ 线程池状态（队列、活跃线程）                        │   │
│  │    ✓ 任务队列状态（等待、执行、失败）                    │   │
│  │                                                          │   │
│  │ 2. 性能指标监控                                          │   │
│  │    ✓ 慢查询处理速率（QPS）                               │   │
│  │    ✓ AI 分析耗时（平均、最大、P99）                      │   │
│  │    ✓ 数据库查询耗时                                      │   │
│  │    ✓ 内存/CPU 使用率                                     │   │
│  │                                                          │   │
│  │ 3. 告警规则引擎                                          │   │
│  │    ✓ 阈值告警（超过配置值触发）                          │   │
│  │    ✓ 异常告警（系统异常、失败率上升）                    │   │
│  │    ✓ 趋势告警（性能持续恶化）                            │   │
│  │                                                          │   │
│  │ 4. 通知发送实现                                          │   │
│  │    ✓ 邮件通知（SMTP）                                    │   │
│  │    ✓ Webhook 通知（钉钉、飞书、企业微信）                │   │
│  │    ✓ 失败重试机制                                        │   │
│  │                                                          │   │
│  │ 5. 告警历史管理                                          │   │
│  │    ✓ 告警记录存储                                        │   │
│  │    ✓ 告警查询（分页、筛选）                              │   │
│  │    ✓ 告警统计（趋势、分布）                              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  【前端】                                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 1. 系统监控仪表盘                                        │   │
│  │    ✓ 实时状态卡片（服务、数据源、队列）                   │   │
│  │    ✓ 性能指标图表（QPS、耗时、成功率）                   │   │
│  │    ✓ 资源使用率图表（内存、CPU、线程池）                 │   │
│  │                                                          │   │
│  │ 2. 告警管理页面                                          │   │
│  │    ✓ 告警列表（分页、筛选、导出）                        │   │
│  │    ✓ 告警详情（触发时间、规则、处理状态）                │   │
│  │    ✓ 告警统计图表（趋势、分布、Top N）                   │   │
│  │                                                          │   │
│  │ 3. 通知配置页面                                          │   │
│  │    ✓ 通知渠道配置（邮件、Webhook、IM）                   │   │
│  │    ✓ 告警规则配置（阈值、级别、策略）                    │   │
│  │    ✓ 通知模板管理                                        │   │
│  │                                                          │   │
│  │ 4. 实时告警通知（前端）                                  │   │
│  │    ✓ WebSocket 实时推送                                  │   │
│  │    ✓ 浏览器通知（Notification API）                      │   │
│  │    ✓ 声音提示                                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. 功能需求概述

### 3.1 功能模块划分

```
监控与通知系统
├── 后端模块
│   ├── 系统健康监控模块
│   ├── 性能指标采集模块
│   ├── 告警规则引擎模块
│   ├── 通知发送服务模块
│   └── 告警历史管理模块
│
└── 前端模块
    ├── 系统监控仪表盘
    ├── 告警管理页面
    ├── 通知配置页面
    └── 实时通知组件
```

### 3.2 核心功能清单

| 功能模块 | 功能点 | 优先级 | 说明 |
|---------|--------|--------|------|
| **系统健康监控** | 服务健康检查 | P0 | 启动时间、版本、JVM 信息 |
| | 数据源状态监控 | P0 | H2、MySQL 连接状态 |
| | 线程池监控 | P1 | 队列长度、活跃线程数 |
| | 队列状态监控 | P1 | 等待/执行/失败任务数 |
| **性能指标采集** | 慢查询处理速率 | P0 | QPS、峰值 |
| | AI 分析耗时统计 | P0 | 平均、最大、P99 |
| | 数据库查询耗时 | P1 | 慢查询统计 |
| | JVM 资源监控 | P2 | 内存、CPU 使用率 |
| **告警规则引擎** | 阈值告警 | P0 | 配置化阈值规则 |
| | 异常告警 | P0 | 系统异常、失败率 |
| | 趋势告警 | P1 | 性能恶化检测 |
| | 告警去重与聚合 | P1 | 防止告警风暴 |
| **通知发送服务** | 邮件通知 | P0 | SMTP 发送 |
| | Webhook 通知 | P0 | 钉钉/飞书/企业微信 |
| | 失败重试机制 | P1 | 3 次重试，指数退避 |
| | 通知模板管理 | P2 | 支持自定义模板 |
| **告警历史管理** | 告警记录存储 | P0 | 完整告警历史 |
| | 告警查询 | P1 | 分页、筛选、排序 |
| | 告警统计 | P2 | 趋势、分布分析 |
| **前端界面** | 系统监控仪表盘 | P0 | 实时状态 + 历史趋势 |
| | 告警管理页面 | P0 | 列表、详情、统计 |
| | 通知配置页面 | P0 | 渠道、规则、模板 |
| | 实时通知推送 | P1 | WebSocket + 浏览器通知 |

**优先级说明**：
- **P0**: 必须实现，核心功能
- **P1**: 重要功能，第一迭代完成
- **P2**: 增强功能，后续迭代完善

---

## 4. 后端设计

### 4.1 包结构设计

```
src/main/java/com/dbdoctor/
├── monitoring/                    # 监控模块（新增）
│   ├── health/                    # 健康检查
│   │   ├── HealthCheckService.java           # 健康检查服务
│   │   ├── HealthIndicator.java              # 健康指标接口
│   │   ├── DataSourceHealthIndicator.java    # 数据源健康指标
│   │   ├── ThreadPoolHealthIndicator.java    # 线程池健康指标
│   │   └── QueueHealthIndicator.java         # 队列健康指标
│   │
│   ├── metrics/                   # 性能指标采集
│   │   ├── MetricsCollector.java             # 指标采集器
│   │   ├── SlowQueryMetrics.java             # 慢查询指标
│   │   ├── AiAnalysisMetrics.java            # AI 分析指标
│   │   └── SystemResourceMetrics.java        # 系统资源指标
│   │
│   ├── alert/                     # 告警引擎
│   │   ├── AlertRuleEngine.java              # 告警规则引擎
│   │   ├── AlertRule.java                    # 告警规则实体
│   │   ├── AlertCondition.java               # 告警条件
│   │   ├── ThresholdAlertRule.java           # 阈值告警规则
│   │   ├── AnomalyAlertRule.java             # 异常告警规则
│   │   └── TrendAlertRule.java               # 趋势告警规则
│   │
│   ├── notification/             # 通知发送
│   │   ├── NotificationService.java          # 通知服务接口
│   │   ├── NotificationServiceImpl.java       # 通知服务实现
│   │   ├── EmailNotifier.java                # 邮件通知器
│   │   ├── WebhookNotifier.java              # Webhook 通知器
│   │   ├── DingTalkNotifier.java             # 钉钉通知器
│   │   ├── FeishuNotifier.java               # 飞书通知器
│   │   ├── WeComNotifier.java                # 企业微信通知器
│   │   ├── NotificationTemplate.java         # 通知模板
│   │   └── NotificationRetryService.java     # 通知重试服务
│   │
│   └── alert/                     # 告警历史
│       ├── AlertHistory.java                 # 告警历史实体
│       ├── AlertHistoryRepository.java       # 告警历史仓储
│       ├── AlertHistoryService.java          # 告警历史服务
│       └── AlertStatisticsService.java       # 告警统计服务
│
├── controller/                       # 控制器
│   ├── MonitoringController.java            # 监控 API
│   ├── AlertController.java                 # 告警 API
│   └── NotificationConfigController.java    # 通知配置 API
│
└── config/                           # 配置
    ├── MonitoringProperties.java            # 监控配置属性
    ├── AlertRuleConfig.java                 # 告警规则配置
    └── WebSocketConfig.java                 # WebSocket 配置
```

### 4.2 核心类设计

#### 4.2.1 健康检查服务

**HealthCheckService.java**

```java
package com.dbdoctor.monitoring.health;

import lombok.Data;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * 系统健康检查服务
 * 定期采集系统各组件的健康状态
 */
@Service
@Slf4j
public class HealthCheckService {

    @Autowired
    private List<HealthIndicator> healthIndicators;

    @Autowired
    private DynamicDataSourceManager dataSourceManager;

    @Autowired
    private AiConfig aiConfig;

    /**
     * 执行健康检查
     * @return 健康检查结果
     */
    public HealthCheckResult performHealthCheck() {
        HealthCheckResult result = new HealthCheckResult();
        result.setCheckTime(LocalDateTime.now());
        result.setStatus("UP");

        Map<String, IndicatorStatus> indicators = new HashMap<>();

        // 执行所有健康指标检查
        for (HealthIndicator indicator : healthIndicators) {
            try {
                IndicatorStatus status = indicator.check();
                indicators.put(indicator.getName(), status);

                // 如果有指标不健康，整体状态降级
                if (!status.isHealthy()) {
                    result.setStatus("DEGRADED");
                }
            } catch (Exception e) {
                log.error("健康指标检查失败: {}", indicator.getName(), e);
                result.setStatus("DOWN");
            }
        }

        result.setIndicators(indicators);
        return result;
    }

    /**
     * 获取系统启动信息
     */
    public SystemInfo getSystemInfo() {
        SystemInfo info = new SystemInfo();
        info.setStartTime(ManagementFactory.getRuntimeMXBean().getStartTime());
        info.setVersion(DbDoctorProperties.VERSION);
        info.setJavaVersion(System.getProperty("java.version"));
        info.setJvmMemory(getJvmMemoryInfo());
        return info;
    }

    @Data
    public static class HealthCheckResult {
        private LocalDateTime checkTime;
        private String status;  // UP, DEGRADED, DOWN
        private Map<String, IndicatorStatus> indicators;
    }

    @Data
    public static class IndicatorStatus {
        private boolean healthy;
        private String message;
        private Map<String, Object> details;
    }

    @Data
    public static class SystemInfo {
        private Long startTime;
        private String version;
        private String javaVersion;
        private JvmMemoryInfo jvmMemory;
    }
}
```

#### 4.2.2 告警规则引擎

**AlertRuleEngine.java**

```java
package com.dbdoctor.monitoring.alert;

import lombok.Data;
import org.springframework.stereotype.Service;
import java.util.List;

/**
 * 告警规则引擎
 * 根据配置的规则评估是否需要触发告警
 */
@Service
@Slf4j
public class AlertRuleEngine {

    @Autowired
    private AlertRuleRepository alertRuleRepository;

    @Autowired
    private AlertHistoryService alertHistoryService;

    @Autowired
    private NotificationService notificationService;

    /**
     * 评估告警规则
     * @param metrics 性能指标数据
     */
    public void evaluateRules(MetricsData metrics) {
        // 查询所有启用的告警规则
        List<AlertRule> rules = alertRuleRepository.findByEnabled(true);

        for (AlertRule rule : rules) {
            try {
                if (shouldTriggerAlert(rule, metrics)) {
                    // 触发告警
                    triggerAlert(rule, metrics);
                }
            } catch (Exception e) {
                log.error("告警规则评估失败: {}", rule.getName(), e);
            }
        }
    }

    /**
     * 判断是否应该触发告警
     */
    private boolean shouldTriggerAlert(AlertRule rule, MetricsData metrics) {
        // 检查冷却期（避免告警风暴）
        if (isInCoolDownPeriod(rule)) {
            return false;
        }

        // 根据规则类型判断
        return switch (rule.getType()) {
            case THRESHOLD -> evaluateThresholdRule(rule, metrics);
            case ANOMALY -> evaluateAnomalyRule(rule, metrics);
            case TREND -> evaluateTrendRule(rule, metrics);
        };
    }

    /**
     * 触发告警
     */
    private void triggerAlert(AlertRule rule, MetricsData metrics) {
        // 创建告警历史记录
        AlertHistory alert = AlertHistory.builder()
            .ruleId(rule.getId())
            .ruleName(rule.getName())
            .severity(rule.getSeverity())
            .status(AlertStatus.FIRING)
            .message(buildAlertMessage(rule, metrics))
            .metrics(metrics)
            .triggeredAt(LocalDateTime.now())
            .build();

        alertHistoryService.save(alert);

        // 发送通知
        notificationService.sendNotification(alert);

        // 更新最后告警时间（用于冷却期判断）
        updateLastAlertTime(rule);
    }
}
```

#### 4.2.3 通知服务实现

**NotificationServiceImpl.java**

```java
package com.dbdoctor.monitoring.notification;

import lombok.Data;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;
import java.util.List;

/**
 * 通知服务实现
 * 支持多种通知渠道：邮件、Webhook、钉钉、飞书、企业微信
 */
@Service
@Slf4j
public class NotificationServiceImpl implements NotificationService {

    @Autowired
    private JavaMailSender mailSender;

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private List<Notifier> notifiers;

    @Autowired
    private NotificationRetryService retryService;

    /**
     * 发送通知（根据配置选择渠道）
     */
    @Override
    public NotificationResult sendNotification(AlertHistory alert) {
        // 获取通知配置
        NotificationConfig config = getNotificationConfig(alert.getSeverity());

        NotificationResult result = new NotificationResult();
        result.setAlertId(alert.getId());
        result.setSentAt(LocalDateTime.now());

        // 并行发送到所有启用的渠道
        List<CompletableFuture<ChannelResult>> futures = config.getEnabledChannels()
            .stream()
            .map(channel -> sendNotificationAsync(channel, alert))
            .toList();

        // 等待所有发送完成
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

        // 收集结果
        List<ChannelResult> channelResults = futures.stream()
            .map(CompletableFuture::join)
            .toList();

        result.setChannelResults(channelResults);

        // 判断是否全部成功
        boolean allSuccess = channelResults.stream()
            .allMatch(ChannelResult::isSuccess);

        result.setSuccess(allSuccess);

        // 如果有失败，加入重试队列
        if (!allSuccess) {
            retryService.addToRetryQueue(alert);
        }

        return result;
    }

    /**
     * 异步发送通知到指定渠道
     */
    private CompletableFuture<ChannelResult> sendNotificationAsync(
        NotificationChannel channel, AlertHistory alert) {

        return CompletableFuture.supplyAsync(() -> {
            try {
                Notifier notifier = getNotifier(channel);
                return notifier.notify(alert);
            } catch (Exception e) {
                log.error("通知发送失败: channel={}, alertId={}",
                    channel, alert.getId(), e);
                return ChannelResult.failed(channel, e.getMessage());
            }
        });
    }

    /**
     * 根据渠道类型获取对应的通知器
     */
    private Notifier getNotifier(NotificationChannel channel) {
        return notifiers.stream()
            .filter(n -> n.supports(channel))
            .findFirst()
            .orElseThrow(() -> new IllegalArgumentException("不支持的通知渠道: " + channel));
    }
}
```

#### 4.2.4 邮件通知器

**EmailNotifier.java**

```java
package com.dbdoctor.monitoring.notification;

import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Component;
import javax.mail.internet.MimeMessage;

/**
 * 邮件通知器
 * 使用 SMTP 协议发送告警邮件
 */
@Component
@Slf4j
public class EmailNotifier implements Notifier {

    @Autowired
    private JavaMailSender mailSender;

    @Value("${db-doctor.notification.mail.from}")
    private String fromEmail;

    @Value("${db-doctor.notification.mail.subject-prefix: [DB-Doctor告警]}")
    private String subjectPrefix;

    @Override
    public boolean supports(NotificationChannel channel) {
        return channel == NotificationChannel.EMAIL;
    }

    @Override
    public ChannelResult notify(AlertHistory alert) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");

            // 发件人
            helper.setFrom(fromEmail);

            // 收件人（从配置获取）
            List<String> recipients = getRecipients(alert.getSeverity());
            helper.setTo(recipients.toArray(new String[0]));

            // 主题
            String subject = String.format("%s %s - %s",
                subjectPrefix,
                alert.getSeverity(),
                alert.getRuleName());
            helper.setSubject(subject);

            // 内容（HTML 格式）
            String content = buildEmailContent(alert);
            helper.setText(content, true);

            // 发送
            mailSender.send(message);

            log.info("告警邮件发送成功: alertId={}, recipients={}",
                alert.getId(), recipients);

            return ChannelResult.success(NotificationChannel.EMAIL);

        } catch (Exception e) {
            log.error("告警邮件发送失败: alertId={}", alert.getId(), e);
            return ChannelResult.failed(NotificationChannel.EMAIL, e.getMessage());
        }
    }

    /**
     * 构建邮件内容（HTML 格式）
     */
    private String buildEmailContent(AlertHistory alert) {
        return String.format("""
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <style>
                    body { font-family: Arial, sans-serif; }
                    .alert-box {
                        border: 1px solid #ddd;
                        border-left-width: 5px;
                        border-left-color: %s;
                        padding: 15px;
                        margin: 10px 0;
                    }
                    .alert-title { font-size: 18px; font-weight: bold; margin-bottom: 10px; }
                    .alert-time { color: #666; font-size: 14px; }
                    .alert-message { margin-top: 15px; white-space: pre-wrap; }
                </style>
            </head>
            <body>
                <h2>DB-Doctor 系统告警</h2>
                <div class="alert-box">
                    <div class="alert-title">%s - %s</div>
                    <div class="alert-time">触发时间: %s</div>
                    <div class="alert-message">%s</div>
                </div>
                <p>请登录 DB-Doctor 系统查看详情。</p>
            </body>
            </html>
            """,
            getSeverityColor(alert.getSeverity()),
            alert.getSeverity(),
            alert.getRuleName(),
            alert.getTriggeredAt(),
            alert.getMessage()
        );
    }
}
```

#### 4.2.5 Webhook 通知器（钉钉/飞书/企业微信）

**DingTalkNotifier.java**

```java
package com.dbdoctor.monitoring.notification;

import org.springframework.stereotype.Component;
import java.util.HashMap;
import java.util.Map;

/**
 * 钉钉通知器
 * 使用钉钉机器人 Webhook 发送告警消息
 */
@Component
@Slf4j
public class DingTalkNotifier implements Notifier {

    @Autowired
    private RestTemplate restTemplate;

    @Value("${db-doctor.notification.webhook.dingtalk.webhook:}")
    private String webhookUrl;

    @Value("${db-doctor.notification.webhook.dingtalk.secret:}")
    private String webhookSecret;

    @Override
    public boolean supports(NotificationChannel channel) {
        return channel == NotificationChannel.DINGTALK;
    }

    @Override
    public ChannelResult notify(AlertHistory alert) {
        try {
            // 构建钉钉消息格式
            Map<String, Object> message = buildDingTalkMessage(alert);

            // 如果配置了密钥，添加签名
            if (StringUtils.hasText(webhookSecret)) {
                String sign = generateSign(webhookSecret);
                message.put("sign", sign);
            }

            // 发送 HTTP POST 请求
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);

            HttpEntity<Map<String, Object>> entity =
                new HttpEntity<>(message, headers);

            ResponseEntity<String> response = restTemplate.postForEntity(
                webhookUrl, entity, String.class);

            // 钉钉返回格式: {"errcode":0,"errmsg":"ok"}
            if (response.getStatusCode().is2xxSuccessful()) {
                log.info("钉钉通知发送成功: alertId={}", alert.getId());
                return ChannelResult.success(NotificationChannel.DINGTALK);
            } else {
                log.error("钉钉通知发送失败: alertId={}, response={}",
                    alert.getId(), response.getBody());
                return ChannelResult.failed(NotificationChannel.DINGTALK, response.getBody());
            }

        } catch (Exception e) {
            log.error("钉钉通知发送失败: alertId={}", alert.getId(), e);
            return ChannelResult.failed(NotificationChannel.DINGTALK, e.getMessage());
        }
    }

    /**
     * 构建钉钉消息格式（Markdown 类型）
     */
    private Map<String, Object> buildDingTalkMessage(AlertHistory alert) {
        Map<String, Object> message = new HashMap<>();

        message.put("msgtype", "markdown");

        Map<String, String> markdown = new HashMap<>();
        markdown.put("title",
            String.format("【%s】%s", alert.getSeverity(), alert.getRuleName()));

        markdown.put("text", String.format("""
            ## DB-Doctor 系统告警

            > **级别**: %s
            > **规则**: %s
            > **时间**: %s

            ### 告警内容

            %s

            ---
            *请登录 DB-Doctor 系统查看详情*
            """,
            alert.getSeverity(),
            alert.getRuleName(),
            alert.getTriggeredAt(),
            alert.getMessage()
        ));

        message.put("markdown", markdown);

        return message;
    }
}
```

### 4.3 配置属性设计

**MonitoringProperties.java**

```java
package com.dbdoctor.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import java.util.Map;

/**
 * 监控配置属性
 */
@Data
@Component
@ConfigurationProperties(prefix = "db-doctor.monitoring")
public class MonitoringProperties {

    /**
     * 健康检查配置
     */
    private HealthCheck healthCheck = new HealthCheck();

    /**
     * 指标采集配置
     */
    private MetricsCollection metricsCollection = new MetricsCollection();

    /**
     * 告警配置
     */
    private Alert alert = new Alert();

    @Data
    public static class HealthCheck {
        /**
         * 检查间隔（秒）
         */
        private int intervalSeconds = 60;

        /**
         * 是否启用健康检查
         */
        private boolean enabled = true;
    }

    @Data
    public static class MetricsCollection {
        /**
         * 慢查询指标采集
         */
        private SlowQuery slowQuery = new SlowQuery();

        /**
         * AI 分析指标采集
         */
        private AiAnalysis aiAnalysis = new AiAnalysis();

        @Data
        public static class SlowQuery {
            /**
             * 采集间隔（秒）
             */
            private int intervalSeconds = 30;

            /**
             * 是否启用
             */
            private boolean enabled = true;
        }

        @Data
        public static class AiAnalysis {
            /**
             * 采集间隔（秒）
             */
            private int intervalSeconds = 60;

            /**
             * 是否启用
             */
            private boolean enabled = true;
        }
    }

    @Data
    public static class Alert {
        /**
         * 告警规则配置
         */
        private Map<String, AlertRuleConfig> rules = new HashMap<>();

        /**
         * 冷却期配置
         */
        private CoolDown coolDown = new CoolDown();

        @Data
        public static class AlertRuleConfig {
            /**
             * 是否启用
             */
            private boolean enabled = true;

            /**
             * 阈值
             */
            private double threshold;

            /**
             * 严重程度
             */
            private String severity;
        }

        @Data
        public static class CoolDown {
            /**
             * 默认冷却期（分钟）
             */
            private int defaultMinutes = 30;

            /**
             * 每个规则的冷却期
             */
            private Map<String, Integer> ruleCoolDownMinutes = new HashMap<>();
        }
    }
}
```

**application.yml 配置示例**

```yaml
db-doctor:
  monitoring:
    # 健康检查
    health-check:
      enabled: true
      interval-seconds: 60

    # 指标采集
    metrics-collection:
      slow-query:
        enabled: true
        interval-seconds: 30
      ai-analysis:
        enabled: true
        interval-seconds: 60

    # 告警配置
    alert:
      rules:
        # 慢查询处理速率告警
        slow-query-qps:
          enabled: true
          threshold: 10.0  # 每秒超过10个慢查询
          severity: WARNING

        # AI 分析耗时告警
        ai-analysis-duration:
          enabled: true
          threshold: 30.0  # 平均耗时超过30秒
          severity: CRITICAL

        # 队列积压告警
        queue-backlog:
          enabled: true
          threshold: 100.0  # 队列积压超过100
          severity: WARNING

        # 数据源连接失败告警
        datasource-failure:
          enabled: true
          threshold: 1.0  # 连接失败
          severity: CRITICAL

      cool-down:
        default-minutes: 30
        rule-cool-down-minutes:
          slow-query-qps: 15
          ai-analysis-duration: 60

  # 通知配置
  notification:
    # 邮件通知
    mail:
      enabled: true
      host: smtp.example.com
      port: 587
      username: your-email@example.com
      password: your-password
      from: DB-Doctor <noreply@dbdoctor.com>
      to:
        CRITICAL: admin@example.com,ops@example.com
        WARNING: ops@example.com
        INFO: dev@example.com
      subject-prefix: "[DB-Doctor告警]"

    # Webhook 通知
    webhook:
      dingtalk:
        enabled: true
        webhook: https://oapi.dingtalk.com/robot/send?access_token=xxx
        secret: SECxxxxxxxxxxxx
      feishu:
        enabled: false
        webhook: https://open.feishu.cn/open-apis/bot/v2/hook/xxx
      wecom:
        enabled: false
        webhook: https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxx

    # 通知重试
    retry:
      enabled: true
      max-attempts: 3
      backoff-multiplier: 2.0
      initial-delay-seconds: 10
```

---

## 5. 前端设计

### 5.1 页面结构

```
frontend/src/
├── views/
│   ├── Monitoring/                    # 监控模块（新增）
│   │   ├── SystemHealth.vue           # 系统健康监控页面
│   │   ├── PerformanceMetrics.vue     # 性能指标监控页面
│   │   ├── AlertManagement.vue        # 告警管理页面
│   │   └── NotificationConfig.vue     # 通知配置页面
│   │
│   └── Dashboard/
│       └── Dashboard.vue              # 仪表盘（已有，需扩展）
│
└── components/
    ├── monitoring/                    # 监控组件（新增）
    │   ├── HealthStatusCard.vue       # 健康状态卡片
    │   ├── MetricChart.vue            # 指标图表组件
    │   ├── AlertList.vue              # 告警列表组件
    │   ├── AlertDetailDialog.vue      # 告警详情弹窗
    │   └── RealtimeAlertToast.vue     # 实时告警提示
    │
    └── charts/                        # 图表组件
        ├── LineChart.vue              # 折线图
        ├── BarChart.vue               # 柱状图
        ├── PieChart.vue               # 饼图
        └── GaugeChart.vue             # 仪表盘图
```

### 5.2 核心页面设计

#### 5.2.1 系统健康监控页面

**SystemHealth.vue**

```vue
<template>
  <div class="system-health">
    <!-- 页面头部 -->
    <div class="page-header">
      <h1>系统健康监控</h1>
      <el-button @click="refreshData" :loading="loading">
        <el-icon><Refresh /></el-icon> 刷新
      </el-button>
    </div>

    <!-- 系统信息卡片 -->
    <el-card class="info-card" shadow="never">
      <template #header>
        <span class="card-title">系统信息</span>
      </template>
      <div class="info-grid">
        <div class="info-item">
          <label>版本号</label>
          <span>{{ systemInfo.version }}</span>
        </div>
        <div class="info-item">
          <label>启动时间</label>
          <span>{{ systemInfo.startTime }}</span>
        </div>
        <div class="info-item">
          <label>运行时长</label>
          <span>{{ systemInfo.uptime }}</span>
        </div>
        <div class="info-item">
          <label>Java 版本</label>
          <span>{{ systemInfo.javaVersion }}</span>
        </div>
      </div>
    </el-card>

    <!-- 健康指标卡片 -->
    <div class="health-indicators">
      <el-card
        v-for="indicator in healthIndicators"
        :key="indicator.name"
        class="indicator-card"
        :class="getIndicatorClass(indicator.healthy)"
        shadow="hover"
      >
        <div class="indicator-header">
          <el-icon class="indicator-icon">
            <component :is="getIndicatorIcon(indicator.name)" />
          </el-icon>
          <span class="indicator-name">{{ indicator.displayName }}</span>
          <el-tag
            :type="indicator.healthy ? 'success' : 'danger'"
            size="small"
          >
            {{ indicator.healthy ? '正常' : '异常' }}
          </el-tag>
        </div>
        <div class="indicator-message">
          {{ indicator.message }}
        </div>
        <div v-if="indicator.details" class="indicator-details">
          <el-descriptions :column="2" size="small">
            <el-descriptions-item
              v-for="(value, key) in indicator.details"
              :key="key"
              :label="key"
            >
              {{ value }}
            </el-descriptions-item>
          </el-descriptions>
        </div>
      </el-card>
    </div>

    <!-- 资源使用率图表 -->
    <div class="resource-charts">
      <el-card class="chart-card" shadow="never">
        <template #header>
          <span class="card-title">JVM 内存使用率</span>
        </template>
        <MetricChart
          type="gauge"
          :data="memoryUsageData"
          :options="gaugeChartOptions"
        />
      </el-card>

      <el-card class="chart-card" shadow="never">
        <template #header>
          <span class="card-title">线程池状态</span>
        </template>
        <MetricChart
          type="line"
          :data="threadPoolData"
          :options="lineChartOptions"
        />
      </el-card>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { Refresh } from '@element-plus/icons-vue'
import { systemHealthApi } from '@/api/monitoring'
import MetricChart from '@/components/charts/MetricChart.vue'

// 响应式数据
const loading = ref(false)
const systemInfo = ref({})
const healthIndicators = ref([])
const memoryUsageData = ref([])
const threadPoolData = ref([])

let refreshTimer: number | null = null

// 加载数据
const loadData = async () => {
  loading.value = true
  try {
    const [healthRes, metricsRes] = await Promise.all([
      systemHealthApi.getHealthStatus(),
      systemHealthApi.getSystemMetrics()
    ])

    systemInfo.value = healthRes.data.systemInfo
    healthIndicators.value = healthRes.data.indicators
    memoryUsageData.value = metricsRes.data.memory
    threadPoolData.value = metricsRes.data.threadPool
  } catch (error) {
    console.error('加载健康监控数据失败:', error)
    ElMessage.error('加载数据失败')
  } finally {
    loading.value = false
  }
}

// 刷新数据
const refreshData = () => {
  loadData()
}

// 定时刷新
onMounted(() => {
  loadData()
  refreshTimer = window.setInterval(() => {
    loadData()
  }, 30000) // 每 30 秒刷新
})

onUnmounted(() => {
  if (refreshTimer) {
    clearInterval(refreshTimer)
  }
})
</script>

<style scoped lang="scss">
.system-health {
  padding: 20px;

  .page-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
  }

  .health-indicators {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
  }

  .indicator-card {
    transition: all 0.3s;

    &.healthy {
      border-left: 4px solid var(--color-success);
    }

    &.unhealthy {
      border-left: 4px solid var(--color-danger);
    }
  }

  .indicator-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
  }

  .indicator-icon {
    font-size: 24px;
  }

  .indicator-name {
    font-weight: 600;
    flex: 1;
  }

  .resource-charts {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
  }
}
</style>
```

#### 5.2.2 告警管理页面

**AlertManagement.vue**

```vue
<template>
  <div class="alert-management">
    <!-- 页面头部 -->
    <div class="page-header">
      <h1>告警管理</h1>
      <div class="header-actions">
        <el-button @click="exportAlerts">
          <el-icon><Download /></el-icon> 导出
        </el-button>
        <el-button type="primary" @click="showAddRuleDialog">
          <el-icon><Plus /></el-icon> 新增规则
        </el-button>
      </div>
    </div>

    <!-- 统计卡片 -->
    <div class="stats-cards">
      <el-card class="stat-card" shadow="hover">
        <div class="stat-value">{{ stats.total }}</div>
        <div class="stat-label">总告警数</div>
      </el-card>
      <el-card class="stat-card" shadow="hover">
        <div class="stat-value critical">{{ stats.critical }}</div>
        <div class="stat-label">严重告警</div>
      </el-card>
      <el-card class="stat-card" shadow="hover">
        <div class="stat-value warning">{{ stats.warning }}</div>
        <div class="stat-label">警告告警</div>
      </el-card>
      <el-card class="stat-card" shadow="hover">
        <div class="stat-value success">{{ stats.resolved }}</div>
        <div class="stat-label">已解决</div>
      </el-card>
    </div>

    <!-- 搜索筛选 -->
    <el-card class="filter-card" shadow="never">
      <el-form :model="filters" inline>
        <el-form-item label="严重程度">
          <el-select v-model="filters.severity" placeholder="全部" clearable>
            <el-option label="严重" value="CRITICAL" />
            <el-option label="警告" value="WARNING" />
            <el-option label="信息" value="INFO" />
          </el-select>
        </el-form-item>
        <el-form-item label="状态">
          <el-select v-model="filters.status" placeholder="全部" clearable>
            <el-option label="触发中" value="FIRING" />
            <el-option label="已解决" value="RESOLVED" />
          </el-select>
        </el-form-item>
        <el-form-item label="时间范围">
          <el-date-picker
            v-model="filters.timeRange"
            type="datetimerange"
            range-separator="至"
            start-placeholder="开始时间"
            end-placeholder="结束时间"
          />
        </el-form-item>
        <el-form-item>
          <el-button type="primary" @click="loadAlerts">查询</el-button>
          <el-button @click="resetFilters">重置</el-button>
        </el-form-item>
      </el-form>
    </el-card>

    <!-- 告警列表 -->
    <el-card class="table-card" shadow="never">
      <el-table
        :data="alerts"
        v-loading="loading"
        stripe
        @row-click="showAlertDetail"
      >
        <el-table-column prop="ruleName" label="告警规则" width="200" />
        <el-table-column prop="severity" label="严重程度" width="120">
          <template #default="{ row }">
            <el-tag :type="getSeverityTagType(row.severity)">
              {{ row.severity }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="status" label="状态" width="120">
          <template #default="{ row }">
            <el-tag :type="getStatusTagType(row.status)">
              {{ getStatusText(row.status) }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="message" label="告警内容" show-overflow-tooltip />
        <el-table-column prop="triggeredAt" label="触发时间" width="180" />
        <el-table-column label="操作" width="150" fixed="right">
          <template #default="{ row }">
            <el-button
              v-if="row.status === 'FIRING'"
              type="success"
              size="small"
              @click.stop="resolveAlert(row)"
            >
              标记解决
            </el-button>
            <el-button
              type="primary"
              size="small"
              @click.stop="showAlertDetail(row)"
            >
              查看详情
            </el-button>
          </template>
        </el-table-column>
      </el-table>

      <!-- 分页 -->
      <el-pagination
        v-model:current-page="pagination.page"
        v-model:page-size="pagination.size"
        :total="pagination.total"
        :page-sizes="[10, 20, 50, 100]"
        layout="total, sizes, prev, pager, next, jumper"
        @size-change="loadAlerts"
        @current-change="loadAlerts"
      />
    </el-card>

    <!-- 告警详情弹窗 -->
    <AlertDetailDialog
      v-model="detailDialogVisible"
      :alert="selectedAlert"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { Plus, Download } from '@element-plus/icons-vue'
import { alertApi } from '@/api/monitoring'
import AlertDetailDialog from '@/components/monitoring/AlertDetailDialog.vue'

// 响应式数据
const loading = ref(false)
const alerts = ref([])
const stats = ref({
  total: 0,
  critical: 0,
  warning: 0,
  resolved: 0
})
const filters = ref({
  severity: '',
  status: '',
  timeRange: null
})
const pagination = ref({
  page: 1,
  size: 20,
  total: 0
})
const detailDialogVisible = ref(false)
const selectedAlert = ref(null)

// 加载告警列表
const loadAlerts = async () => {
  loading.value = true
  try {
    const res = await alertApi.getAlerts({
      ...filters.value,
      page: pagination.value.page,
      size: pagination.value.size
    })

    alerts.value = res.data.list
    pagination.value.total = res.data.total
  } catch (error) {
    console.error('加载告警列表失败:', error)
    ElMessage.error('加载失败')
  } finally {
    loading.value = false
  }
}

// 加载统计数据
const loadStats = async () => {
  try {
    const res = await alertApi.getAlertStats()
    stats.value = res.data
  } catch (error) {
    console.error('加载统计数据失败:', error)
  }
}

// 解决告警
const resolveAlert = async (alert) => {
  try {
    await alertApi.resolveAlert(alert.id)
    ElMessage.success('已标记为解决')
    loadAlerts()
    loadStats()
  } catch (error) {
    ElMessage.error('操作失败')
  }
}

onMounted(() => {
  loadAlerts()
  loadStats()
})
</script>
```

### 5.3 WebSocket 实时推送

**WebSocket 配置**

```java
package com.dbdoctor.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.*;
import org.springframework.web.socket.handler.TextWebSocketHandler;

/**
 * WebSocket 配置
 * 用于实时推送告警通知到前端
 */
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Autowired
    private AlertWebSocketHandler alertWebSocketHandler;

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(alertWebSocketHandler, "/ws/alerts")
            .setAllowedOrigins("*")  // 生产环境应限制来源
            .withSockJS();  // 支持 SockJS 降级
    }
}
```

**AlertWebSocketHandler.java**

```java
package com.dbdoctor.monitoring.websocket;

import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * 告警 WebSocket 处理器
 * 将告警实时推送给所有连接的客户端
 */
@Component
@Slf4j
public class AlertWebSocketHandler extends TextWebSocketHandler {

    // 存储所有活跃的 WebSocket 会话
    private static final CopyOnWriteArraySet<WebSocketSession> sessions =
        new CopyOnWriteArraySet<>();

    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        sessions.add(session);
        log.info("WebSocket 客户端连接: sessionId={}", session.getId());
    }

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
        sessions.remove(session);
        log.info("WebSocket 客户端断开: sessionId={}", session.getId());
    }

    /**
     * 广播告警消息给所有客户端
     */
    public void broadcastAlert(AlertHistory alert) {
        String message = JsonUtil.toJson(alert);

        for (WebSocketSession session : sessions) {
            if (session.isOpen()) {
                try {
                    session.sendMessage(new TextMessage(message));
                } catch (Exception e) {
                    log.error("WebSocket 发送消息失败: sessionId={}",
                        session.getId(), e);
                }
            }
        }
    }
}
```

**前端 WebSocket 连接**

```typescript
// frontend/src/utils/websocket.ts

export class AlertWebSocket {
  private ws: WebSocket | null = null
  private reconnectTimer: number | null = null
  private handlers: ((alert: Alert) => void)[] = []

  connect(url: string) {
    this.ws = new WebSocket(url)

    this.ws.onopen = () => {
      console.log('WebSocket 连接成功')
    }

    this.ws.onmessage = (event) => {
      const alert = JSON.parse(event.data)
      this.handlers.forEach(handler => handler(alert))
    }

    this.ws.onclose = () => {
      console.log('WebSocket 连接断开，5秒后重连...')
      this.reconnectTimer = window.setTimeout(() => {
        this.connect(url)
      }, 5000)
    }

    this.ws.onerror = (error) => {
      console.error('WebSocket 错误:', error)
    }
  }

  onAlert(handler: (alert: Alert) => void) {
    this.handlers.push(handler)
  }

  disconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer)
    }
    if (this.ws) {
      this.ws.close()
    }
  }
}

// 使用示例
const alertWs = new AlertWebSocket()
alertWs.connect('ws://localhost:8080/ws/alerts')

alertWs.onAlert((alert) => {
  // 显示实时告警通知
  ElNotification({
    title: `${alert.severity} - ${alert.ruleName}`,
    message: alert.message,
    type: getNotificationType(alert.severity),
    duration: 0,  // 不自动关闭
  })
})
```

---

## 6. 数据库设计

### 6.1 新增表结构

#### 6.1.1 alert_history（告警历史表）

```sql
CREATE TABLE alert_history (
    id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '主键',
    rule_id BIGINT NOT NULL COMMENT '告警规则ID',
    rule_name VARCHAR(100) NOT NULL COMMENT '告警规则名称',
    severity VARCHAR(20) NOT NULL COMMENT '严重程度: CRITICAL/WARNING/INFO',
    status VARCHAR(20) NOT NULL DEFAULT 'FIRING' COMMENT '状态: FIRING/RESOLVED',
    message TEXT COMMENT '告警消息',
    metrics JSON COMMENT '触发告警时的指标数据',
    triggered_at DATETIME NOT NULL COMMENT '触发时间',
    resolved_at DATETIME COMMENT '解决时间',
    resolved_by VARCHAR(50) COMMENT '解决人',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',

    INDEX idx_status_time (status, triggered_at),
    INDEX idx_severity_time (severity, triggered_at),
    INDEX idx_rule_id (rule_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='告警历史表';
```

#### 6.1.2 alert_rule（告警规则表）

```sql
CREATE TABLE alert_rule (
    id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '主键',
    name VARCHAR(100) NOT NULL UNIQUE COMMENT '规则名称',
    display_name VARCHAR(100) NOT NULL COMMENT '显示名称',
    type VARCHAR(20) NOT NULL COMMENT '规则类型: THRESHOLD/ANOMALY/TREND',
    metric_name VARCHAR(50) NOT NULL COMMENT '指标名称',
    condition_operator VARCHAR(10) NOT NULL COMMENT '比较操作符: >/</=/>=/<='
    threshold_value DOUBLE COMMENT '阈值（类型为THRESHOLD时使用）',
    severity VARCHAR(20) NOT NULL COMMENT '严重程度: CRITICAL/WARNING/INFO',
    enabled BOOLEAN NOT NULL DEFAULT TRUE COMMENT '是否启用',
    cool_down_minutes INT NOT NULL DEFAULT 30 COMMENT '冷却期（分钟）',
    description VARCHAR(500) COMMENT '规则描述',
    created_by VARCHAR(50) COMMENT '创建人',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',

    INDEX idx_enabled (enabled),
    INDEX idx_type (type)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='告警规则表';
```

#### 6.1.3 notification_config（通知配置表）

```sql
CREATE TABLE notification_config (
    id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '主键',
    channel VARCHAR(20) NOT NULL COMMENT '通知渠道: EMAIL/WEBHOOK/DINGTALK/FEISHU/WECOM',
    enabled BOOLEAN NOT NULL DEFAULT TRUE COMMENT '是否启用',
    config JSON NOT NULL COMMENT '渠道配置（JSON格式）',
    severity_levels VARCHAR(50) COMMENT '适用的告警级别: CRITICAL,WARNING,INFO',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',

    UNIQUE KEY uk_channel (channel)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='通知配置表';
```

#### 6.1.4 notification_log（通知发送日志表）

```sql
CREATE TABLE notification_log (
    id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '主键',
    alert_id BIGINT NOT NULL COMMENT '告警ID',
    channel VARCHAR(20) NOT NULL COMMENT '通知渠道',
    recipient VARCHAR(255) COMMENT '接收人',
    status VARCHAR(20) NOT NULL COMMENT '发送状态: SUCCESS/FAILED/PENDING',
    error_message TEXT COMMENT '错误信息',
    retry_count INT NOT NULL DEFAULT 0 COMMENT '重试次数',
    sent_time DATETIME COMMENT '发送时间',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',

    INDEX idx_alert_id (alert_id),
    INDEX idx_status_time (status, created_time),
    INDEX idx_channel_time (channel, created_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='通知发送日志表';
```

### 6.2 数据迁移脚本

**V3.1.0__add_monitoring_and_notification.sql**

```sql
-- ====================================================
-- DB-Doctor v3.1.0 监控与通知功能数据迁移脚本
-- ====================================================

-- 1. 创建告警历史表
CREATE TABLE IF NOT EXISTS alert_history (
    id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '主键',
    rule_id BIGINT NOT NULL COMMENT '告警规则ID',
    rule_name VARCHAR(100) NOT NULL COMMENT '告警规则名称',
    severity VARCHAR(20) NOT NULL COMMENT '严重程度',
    status VARCHAR(20) NOT NULL DEFAULT 'FIRING' COMMENT '状态',
    message TEXT COMMENT '告警消息',
    metrics JSON COMMENT '指标数据',
    triggered_at DATETIME NOT NULL COMMENT '触发时间',
    resolved_at DATETIME COMMENT '解决时间',
    resolved_by VARCHAR(50) COMMENT '解决人',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_status_time (status, triggered_at),
    INDEX idx_severity_time (severity, triggered_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='告警历史表';

-- 2. 创建告警规则表
CREATE TABLE IF NOT EXISTS alert_rule (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE COMMENT '规则名称',
    display_name VARCHAR(100) NOT NULL COMMENT '显示名称',
    type VARCHAR(20) NOT NULL COMMENT '规则类型',
    metric_name VARCHAR(50) NOT NULL COMMENT '指标名称',
    condition_operator VARCHAR(10) NOT NULL COMMENT '操作符',
    threshold_value DOUBLE COMMENT '阈值',
    severity VARCHAR(20) NOT NULL COMMENT '严重程度',
    enabled BOOLEAN NOT NULL DEFAULT TRUE,
    cool_down_minutes INT NOT NULL DEFAULT 30,
    description VARCHAR(500),
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_enabled (enabled)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='告警规则表';

-- 3. 创建通知配置表
CREATE TABLE IF NOT EXISTS notification_config (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    channel VARCHAR(20) NOT NULL UNIQUE COMMENT '通知渠道',
    enabled BOOLEAN NOT NULL DEFAULT TRUE,
    config JSON NOT NULL COMMENT '渠道配置',
    severity_levels VARCHAR(50),
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='通知配置表';

-- 4. 创建通知日志表
CREATE TABLE IF NOT EXISTS notification_log (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    alert_id BIGINT NOT NULL COMMENT '告警ID',
    channel VARCHAR(20) NOT NULL COMMENT '通知渠道',
    recipient VARCHAR(255),
    status VARCHAR(20) NOT NULL COMMENT '发送状态',
    error_message TEXT,
    retry_count INT NOT NULL DEFAULT 0,
    sent_time DATETIME,
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_alert_id (alert_id),
    INDEX idx_status_time (status, created_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='通知发送日志表';

-- 5. 初始化默认告警规则
INSERT INTO alert_rule (name, display_name, type, metric_name, condition_operator, threshold_value, severity, enabled, description) VALUES
('slow-query-qps', '慢查询处理速率告警', 'THRESHOLD', 'slowQueryQps', '>', 10.0, 'WARNING', TRUE, '每秒慢查询数量超过10个'),
('ai-analysis-duration', 'AI分析耗时告警', 'THRESHOLD', 'aiAnalysisDurationAvg', '>', 30.0, 'CRITICAL', TRUE, 'AI分析平均耗时超过30秒'),
('queue-backlog', '队列积压告警', 'THRESHOLD', 'queueBacklog', '>', 100.0, 'WARNING', TRUE, '任务队列积压超过100个'),
('datasource-failure', '数据源连接失败告警', 'ANOMALY', 'datasourceStatus', '=', 1.0, 'CRITICAL', TRUE, '数据源连接失败')
ON DUPLICATE KEY UPDATED updated_time=CURRENT_TIMESTAMP;

-- 6. 初始化系统配置到 system_config 表
INSERT INTO system_config (config_key, config_value, config_group, description) VALUES
('monitoring.health-check.enabled', 'true', 'monitoring', '是否启用健康检查'),
('monitoring.health-check.interval-seconds', '60', 'monitoring', '健康检查间隔（秒）'),
('monitoring.metrics-collection.slow-query.enabled', 'true', 'monitoring', '是否启用慢查询指标采集'),
('monitoring.metrics-collection.slow-query.interval-seconds', '30', 'monitoring', '慢查询指标采集间隔（秒）'),
('monitoring.alert.enabled', 'true', 'monitoring', '是否启用告警'),
('monitoring.alert.cool-down.default-minutes', '30', 'monitoring', '默认告警冷却期（分钟）')
ON DUPLICATE KEY UPDATED updated_time=CURRENT_TIMESTAMP;
```

---

## 7. API 设计

### 7.1 监控 API

#### 7.1.1 获取系统健康状态

```http
GET /api/monitoring/health
```

**响应示例**：

```json
{
  "code": "SUCCESS",
  "data": {
    "checkTime": "2026-02-06T15:30:00",
    "status": "UP",
    "systemInfo": {
      "version": "v3.0.0",
      "startTime": "2026-02-06T08:00:00",
      "uptime": "7小时30分钟",
      "javaVersion": "17.0.2",
      "jvmMemory": {
        "total": 2048,
        "used": 1024,
        "max": 4096
      }
    },
    "indicators": {
      "datasource": {
        "name": "datasource",
        "displayName": "数据源",
        "healthy": true,
        "message": "所有数据源连接正常",
        "details": {
          "h2": "UP",
          "mysql": "UP"
        }
      },
      "threadPool": {
        "name": "threadPool",
        "displayName": "线程池",
        "healthy": true,
        "message": "线程池运行正常",
        "details": {
          "activeCount": 4,
          "corePoolSize": 4,
          "maxPoolSize": 16,
          "queueSize": 10,
          "completedTaskCount": 1523
        }
      },
      "queue": {
        "name": "queue",
        "displayName": "任务队列",
        "healthy": true,
        "message": "无积压任务",
        "details": {
          "waiting": 0,
          "executing": 2,
          "failed": 0
        }
      }
    }
  }
}
```

#### 7.1.2 获取性能指标

```http
GET /api/monitoring/metrics?startTime=2026-02-06T00:00:00&endTime=2026-02-06T15:30:00
```

**响应示例**：

```json
{
  "code": "SUCCESS",
  "data": {
    "slowQueryMetrics": {
      "qps": 5.2,
      "peakQps": 12.0,
      "totalQueries": 15230,
      "avgQueryTime": 2.3,
      "maxQueryTime": 15.8
    },
    "aiAnalysisMetrics": {
      "totalAnalysis": 523,
      "successRate": 0.98,
      "avgDuration": 12.5,
      "maxDuration": 45.2,
      "p99Duration": 28.6
    },
    "systemResourceMetrics": {
      "cpuUsage": 0.35,
      "memoryUsage": 0.52,
      "diskUsage": 0.45
    }
  }
}
```

### 7.2 告警 API

#### 7.2.1 查询告警列表

```http
GET /api/alerts?page=1&size=20&severity=CRITICAL&status=FIRING
```

**响应示例**：

```json
{
  "code": "SUCCESS",
  "data": {
    "total": 152,
    "list": [
      {
        "id": 1,
        "ruleId": 1,
        "ruleName": "AI分析耗时告警",
        "severity": "CRITICAL",
        "status": "FIRING",
        "message": "AI分析平均耗时超过30秒，当前值: 45.2秒",
        "metrics": {
          "avgDuration": 45.2,
          "maxDuration": 68.5,
          "sampleCount": 23
        },
        "triggeredAt": "2026-02-06T15:25:00",
        "resolvedAt": null,
        "resolvedBy": null
      }
    ]
  }
}
```

#### 7.2.2 获取告警统计

```http
GET /api/alerts/stats?timeRange=24h
```

**响应示例**：

```json
{
  "code": "SUCCESS",
  "data": {
    "total": 152,
    "critical": 23,
    "warning": 89,
    "info": 40,
    "resolved": 120,
    "firing": 32,
    "trend": [
      { "time": "2026-02-06T00:00:00", "count": 5 },
      { "time": "2026-02-06T01:00:00", "count": 8 },
      ...
    ]
  }
}
```

#### 7.2.3 标记告警已解决

```http
POST /api/alerts/{id}/resolve
```

**请求体**：

```json
{
  "resolvedBy": "admin",
  "comment": "已优化索引，问题解决"
}
```

### 7.3 通知配置 API

#### 7.3.1 获取通知配置

```http
GET /api/notification/config
```

**响应示例**：

```json
{
  "code": "SUCCESS",
  "data": {
    "channels": [
      {
        "channel": "EMAIL",
        "enabled": true,
        "config": {
          "host": "smtp.example.com",
          "port": 587,
          "from": "noreply@dbdoctor.com",
          "recipients": {
            "CRITICAL": ["admin@example.com"],
            "WARNING": ["ops@example.com"]
          }
        },
        "severityLevels": "CRITICAL,WARNING,INFO"
      },
      {
        "channel": "DINGTALK",
        "enabled": true,
        "config": {
          "webhook": "https://oapi.dingtalk.com/robot/send?access_token=xxx",
          "secret": "SECxxx"
        },
        "severityLevels": "CRITICAL,WARNING"
      }
    ]
  }
}
```

#### 7.3.2 更新通知配置

```http
POST /api/notification/config
```

**请求体**：

```json
{
  "channels": [
    {
      "channel": "EMAIL",
      "enabled": true,
      "config": { ... }
    }
  ]
}
```

---

## 8. 实施计划

### 8.1 迭代规划

**第一阶段：核心监控功能（2周）**

| 任务 | 工作量 | 负责人 |
|------|--------|--------|
| 数据库表结构设计与迁移 | 2天 | 后端 |
| 健康检查服务实现 | 2天 | 后端 |
| 性能指标采集服务 | 3天 | 后端 |
| 系统监控前端页面 | 3天 | 前端 |
| 单元测试与联调 | 2天 | 全员 |

**第二阶段：告警功能（2周）**

| 任务 | 工作量 | 负责人 |
|------|--------|--------|
| 告警规则引擎实现 | 3天 | 后端 |
| 告警历史管理 | 2天 | 后端 |
| 告警管理前端页面 | 3天 | 前端 |
| 告警统计与可视化 | 2天 | 前端 |
| 单元测试与联调 | 2天 | 全员 |

**第三阶段：通知功能（2周）**

| 任务 | 工作量 | 负责人 |
|------|--------|--------|
| 邮件通知实现 | 2天 | 后端 |
| Webhook通知实现（钉钉/飞书/企业微信） | 3天 | 后端 |
| 通知重试机制 | 2天 | 后端 |
| 通知配置前端页面 | 2天 | 前端 |
| WebSocket实时推送 | 2天 | 前后端 |
| 单元测试与联调 | 1天 | 全员 |

**第四阶段：完善与测试（1周）**

| 任务 | 工作量 | 负责人 |
|------|--------|--------|
| 性能优化 | 2天 | 后端 |
| 用户体验优化 | 2天 | 前端 |
| 集成测试 | 2天 | 全员 |
| 文档编写 | 1天 | 全员 |

**总计**：约7周（1.75个月）

### 8.2 里程碑

| 里程碑 | 时间 | 交付物 |
|--------|------|--------|
| M1 | 第2周末 | 核心监控功能上线 |
| M2 | 第4周末 | 告警功能上线 |
| M3 | 第6周末 | 通知功能上线 |
| M4 | 第7周末 | 功能完善与测试完成 |

---

## 9. 验收标准

### 9.1 功能验收

#### 9.1.1 系统健康监控

- ✅ 能够实时显示服务、数据源、线程池、队列的健康状态
- ✅ 能够查看 JVM 内存使用率
- ✅ 健康检查异常时能明显标识
- ✅ 支持手动刷新和自动刷新（30秒间隔）

#### 9.1.2 告警功能

- ✅ 支持配置告警规则（阈值、异常、趋势）
- ✅ 告警触发后能正确记录到数据库
- ✅ 告警列表支持分页、筛选、排序
- ✅ 能够查看告警详情和触发时的指标数据
- ✅ 支持手动标记告警为已解决
- ✅ 告警冷却期机制正常工作（避免告警风暴）

#### 9.1.3 通知功能

- ✅ 邮件通知能正常发送（支持HTML格式）
- ✅ 钉钉 Webhook 通知能正常发送
- ✅ 飞书 Webhook 通知能正常发送
- ✅ 企业微信 Webhook 通知能正常发送
- ✅ 通知发送失败后能自动重试（最多3次）
- ✅ 支持通过配置界面管理通知渠道和收件人

#### 9.1.4 实时推送

- ✅ WebSocket 连接稳定
- ✅ 告警触发后前端能实时收到推送通知
- ✅ 支持浏览器通知（Notification API）
- ✅ 连接断开后能自动重连

### 9.2 性能验收

| 指标 | 目标值 |
|------|--------|
| 健康检查响应时间 | < 100ms |
| 告警列表查询（分页100条） | < 200ms |
| 告警规则评估耗时 | < 50ms |
| 邮件发送耗时 | < 3s |
| Webhook 发送耗时 | < 1s |
| WebSocket 消息延迟 | < 500ms |

### 9.3 稳定性验收

- ✅ 连续运行 24 小时无崩溃
- ✅ 告警规则评估准确率 ≥ 99%
- ✅ 通知发送成功率 ≥ 95%（失败需正确记录）
- ✅ 内存泄漏检测（24小时内存增长 < 10%）

### 9.4 代码质量验收

- ✅ 后端单元测试覆盖率 ≥ 80%
- ✅ 前端组件测试覆盖率 ≥ 70%
- ✅ 无 Critical 级别的 SonarQube 问题
- ✅ 代码符合阿里巴巴 Java 开发规范
- ✅ 所有 API 都有 Swagger 文档

---

## 附录

### A. 依赖清单

**后端新增依赖**：

```xml
<!-- Spring Boot WebSocket -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>

<!-- JavaMail Sender -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>

<!-- Apache Commons Email（简化邮件发送） -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-email</artifactId>
    <version>1.5</version>
</dependency>

<!-- Micrometer Core（指标采集） -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-core</artifactId>
</dependency>

<!-- Hutool（HTTP 客户端，用于 Webhook） -->
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-http</artifactId>
    <version>5.8.27</version>
</dependency>
```

**前端新增依赖**：

```json
{
  "dependencies": {
    "echarts": "^5.4.3",
    "vue-echarts": "^6.6.1",
    "sockjs-client": "^1.6.1",
    "stompjs": "^2.3.3"
  }
}
```

### B. 配置检查清单

部署前需要确认的配置项：

- [ ] SMTP 服务器配置（host、port、username、password）
- [ ] 钉钉机器人 Webhook URL
- [ ] 飞书机器人 Webhook URL
- [ ] 企业微信机器人 Webhook URL
- [ ] 告警规则初始化（通过 SQL 脚本）
- [ ] 通知收件人列表配置
- [ ] WebSocket 允许的来源配置（生产环境）
- [ ] 告警冷却期配置
- [ ] 监控数据采集间隔配置
- [ ] 健康检查间隔配置

### C. 故障排查手册

**常见问题及解决方案**：

| 问题 | 可能原因 | 解决方案 |
|------|---------|---------|
| 邮件发送失败 | SMTP配置错误 | 检查 host、port、认证信息 |
| Webhook 发送失败 | URL 或密钥错误 | 检查 Webhook URL 和 secret |
| 告警未触发 | 规则未启用或阈值不满足 | 检查 alert_rule 表的 enabled 字段 |
| WebSocket 连接失败 | 跨域或端口错误 | 检查 WebSocket 配置和防火墙 |
| 性能指标采集失败 | 权限不足 | 检查 JMX 访问权限 |
| 告警风暴 | 冷却期未生效 | 检查 cool_down_minutes 配置 |

---

## 总结

本报告详细设计了 DB-Doctor 系统的**监控与通知功能**，包括：

1. **系统健康监控**：实时监控服务、数据源、线程池、队列状态
2. **性能指标采集**：慢查询处理速率、AI 分析耗时、系统资源使用率
3. **告警规则引擎**：支持阈值、异常、趋势三种告警类型
4. **多渠道通知**：邮件、钉钉、飞书、企业微信，支持失败重试
5. **告警历史管理**：完整的告警记录、查询、统计
6. **前端可视化**：友好的监控仪表盘、告警管理、通知配置界面
7. **实时推送**：WebSocket + 浏览器通知，实时告警不遗漏

**核心优势**：
- 基于白皮书的现有架构，无缝集成
- 模块化设计，易于扩展和维护
- 配置化管理，灵活适配不同场景
- 完善的错误处理和重试机制
- 企业级的稳定性和性能

**预计工作量**：7 周（1.75 个月）
**预计上线时间**：2026 年 3 月底

---

**文档编写**：Claude (AI 架构师)
**审核**：待定
**批准**：待定
